{"meta":{"title":"董新的博客","subtitle":"董新的博客","description":"董新,react,vue,native,router,api,redux,vuex,技巧,分享,资源","author":"董新","url":"http:/dongxin03.github.io","root":"/"},"pages":[{"title":"董新","date":"2019-11-25T06:36:02.000Z","updated":"2020-08-11T02:35:44.000Z","comments":false,"path":"about/index.html","permalink":"http://dongxin03.github.io/about/index.html","excerpt":"","text":"简介 出生年月：1992.9.24 籍贯：辽宁，阜新 工作经验：3年 现居住地：辽宁，沈阳 年龄：29岁 教育背景 2016.6-2016-12 珠峰培训，学习web前端 工作经历 2017.3-2019.4 北京心更远教育科技有限公司 web前端工程师 负责项目 火花思维h5项目 火花思维pc端项目 主要使用react,redux,dva,antd,antd-mobile,less,postcss 2019.4-至今 沈阳市中国联通辽宁通讯公司 web前端工程师 负责项目 盘锦京环app 智慧校园app 丹东税务坐席端项目 主要使用react-native,vue,vuex,less 项目经历 火花思维h5 火花思维pc端 h5页面嵌入到火花思维app。有产品宣传，课程介绍，我的作业，个人中心，以及宣传使用的landing页面等等 火花思维pc端。宣传介绍火花思维的pc端，有宣传页面，课程简介页面，软件下载页面，关于我们页面，以及免费预约，电话咨询等等。 1、通过react组件化实现组件的复用，便于后期维护。 2、使用 react-router 实现页面跳转。 3、使用 antd,antd-mobile组件库。 4、使用eslink进行团队开发代码统一化。 5、使用postcss 编写css，结构清晰，快速定位样式。 盘锦京环app,智慧校园app 数据统计，分析，消息通知，请加，调休，登录，退出等待； 1、使用react-native搭建的AndroidApp 2、对接百度地图，高德地图实现定位，标记等功能； 3、实现图片上传，文件上传下载等功能。 4、对接echartsjs实现数据展示分析。 5、使用react-redux管理数据 丹东税务 视频交税系统，视频通话，实时图片展示，文件上传下载，数据统计分析，登入登出。 1、使用vue搭建项目 2、使用vuex管理数据 3、对接声网实现视频通话 4、使用webSooket实现实时消息 5、对接echartsjs实现数据展示分析 6、canvas实现摄像头拍照上传功能 7、实时接收图片组件，实现单个图片下载进度条 8、对接扫码枪，实现二维码信息扫入。 9、使用elementUi组件。 技能 react redux vue vuex webSooket react-native(并不想作) electron(简单会点) node(简单会点) python(会爬简单数据) less postcss antd antd-mobile element-ui echarts svn git 其他 自己有电脑mac 常用google查找问题 经常浏览掘金，了解最近技术 有自己的博客"},{"title":"分类","date":"2019-11-25T06:08:25.000Z","updated":"2019-11-25T06:12:50.000Z","comments":false,"path":"categories/index.html","permalink":"http://dongxin03.github.io/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2019-11-25T06:18:27.000Z","updated":"2019-11-25T06:19:08.000Z","comments":false,"path":"links/index.html","permalink":"http://dongxin03.github.io/links/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-25T06:11:57.000Z","updated":"2019-11-25T06:12:45.000Z","comments":false,"path":"tags/index.html","permalink":"http://dongxin03.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"开始学习vue","slug":"开始学习vue","date":"2022-06-10T10:30:06.000Z","updated":"2022-06-10T10:30:06.670Z","comments":true,"path":"2022/06/10/开始学习vue/","link":"","permalink":"http://dongxin03.github.io/2022/06/10/%E5%BC%80%E5%A7%8B%E5%AD%A6%E4%B9%A0vue/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"节流","slug":"节流","date":"2020-12-03T07:42:14.000Z","updated":"2020-12-03T07:42:57.000Z","comments":true,"path":"2020/12/03/节流/","link":"","permalink":"http://dongxin03.github.io/2020/12/03/%E8%8A%82%E6%B5%81/","excerpt":"","text":"func 要执行的函数delay 多少毫秒执行一次 123456789101112let throttle = (func, delay) =&gt; &#123; let prev = Date.now(); return function() &#123; let context = this; let args = arguments; let now = Date.now(); if (now - prev &gt;= delay) &#123; func.apply(context, args); prev = Date.now(); &#125; &#125;;&#125;;","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"js","slug":"js","permalink":"http://dongxin03.github.io/tags/js/"}]},{"title":"常用的一些正则","slug":"常用的一些正则","date":"2020-12-03T07:32:14.000Z","updated":"2020-12-03T07:33:21.000Z","comments":true,"path":"2020/12/03/常用的一些正则/","link":"","permalink":"http://dongxin03.github.io/2020/12/03/%E5%B8%B8%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E6%AD%A3%E5%88%99/","excerpt":"","text":"是不是正确的手机号/^(13[0-9]|14[01456879]|15[0-3,5-9]|16[2567]|17[0-8]|18[0-9]|19[0-3,5-9])\\d{8}$/","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"正则","slug":"正则","permalink":"http://dongxin03.github.io/tags/%E6%AD%A3%E5%88%99/"}]},{"title":"原生JS使用Blob导出csv文件","slug":"原生JS使用Blob导出csv文件","date":"2020-11-18T12:09:38.000Z","updated":"2020-11-18T12:09:45.000Z","comments":true,"path":"2020/11/18/原生JS使用Blob导出csv文件/","link":"","permalink":"http://dongxin03.github.io/2020/11/18/%E5%8E%9F%E7%94%9FJS%E4%BD%BF%E7%94%A8Blob%E5%AF%BC%E5%87%BAcsv%E6%96%87%E4%BB%B6/","excerpt":"","text":"偷来的 怕忘 12345678910111213141516171819202122232425262728let sourceData = &#123;复制代码 head: [ &apos;时间&apos;, &apos;成交价格&apos;, &apos;成交数量&apos;, &apos;手续费&apos;, &apos;成交金额&apos;, ], data: [ &#123;time: &apos;2019-10-17 14:54:52&apos;, tradePrice: &apos;30.0022.001.32 TWD&apos;, fee:&apos;0 TWD&apos;, tradeAmount: &apos;660.00&apos;,&#125;, &#123;time: &apos;2019-10-17 14:54:36&apos;, tradePrice: &apos;30.0089.005.34 TWD&apos;, fee:&apos;0 TWD&apos;, tradeAmount: &apos;2,670.00&apos;,&#125;, &#123;time: &apos;2019-10-17 14:54:07&apos;, tradePrice: &apos;21.00500.0021 TWD&apos;, fee:&apos;0 TWD&apos;, tradeAmount: &apos;10,500.00&apos;,&#125;, ]&#125;// 格式化const data = [sourceData.head.join(&apos;,&apos;)].concat(sourceData.data.map(item =&gt; &#123; return [ item.time, `&quot;$&#123;item.tradePrice&#125;&quot;`, `&quot;$&#123;item.fee&#125;&quot;`, `&quot;$&#123;item.tradeAmount&#125;&quot;`, ].join(&apos;,&apos;)&#125;))// 创建Blob对象 传入一个合适的MIME类型const blob = new Blob([&apos;\\ufeff&apos; + data.join(&apos;\\n&apos;)], &#123;type: &apos;text/csv,charset=UTF-8&apos;&#125;); // 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/API/Blob// 使用 Blob 创建一个指向类型化数组的URLconst csvUrl = URL.createObjectURL(blob); // 参考链接 https://developer.mozilla.org/zh-CN/docs/Web/API/URL/createObjectURLlet link = document.createElement(&apos;a&apos;); link.download = `details_$&#123;new Date().getTime()&#125;.csv`; //文件名字 link.href = csvUrl;// 触发下载link.click(); 1234genUrl(encoded, options) &#123; const dataBlob = new Blob([`\\ufeff$&#123;encoded&#125;`], &#123; type: &apos;text/plain;charset=utf-8&apos; &#125;);//返回的格式 return window.URL.createObjectURL(dataBlob); &#125;, 1234567891011downloadByPeople()&#123; this.$http.FileGet(this.pageParams).then(res =&gt; &#123; const url = this.genUrl(res.data.data.workhour_csv_data, &#123;&#125;);//&#123;&#125;指的是表头，res.data.data.workhour_csv_data是后台返 回来的数据 const a = document.createElement(&apos;a&apos;); a.href = url; a.download = &quot;工时统计文件.csv&quot;; a.click(); window.URL.revokeObjectURL(url); &#125;); &#125;, 注意事项： 数据中存在 ‘,’ 逗号问题处理：将整个数据用双引号(英文格式)包裹起来，这样会显示成一个单元格。 拼接后的数据如何直接下载，不需要用户在操作：动态创建a标签，并调用点击事件 中文乱码解决方案：在数据前面加上字符串”\\ufeff”即可","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"web","slug":"web","permalink":"http://dongxin03.github.io/tags/web/"}]},{"title":"webpack 4.0 整理","slug":"webpack4.0整理","date":"2020-08-28T02:06:18.000Z","updated":"2020-08-28T00:17:02.000Z","comments":true,"path":"2020/08/28/webpack4.0整理/","link":"","permalink":"http://dongxin03.github.io/2020/08/28/webpack4.0%E6%95%B4%E7%90%86/","excerpt":"","text":"整理 webpack 3.0 1、 安装123// 新建文件夹进入npm initnpm install --save-dev webpack // 在生产环境安装 webpack","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"webpack","slug":"webpack","permalink":"http://dongxin03.github.io/tags/webpack/"}]},{"title":"hexo 使用方法","slug":"hexo使用方法","date":"2020-08-28T00:24:11.000Z","updated":"2020-08-28T00:24:11.000Z","comments":true,"path":"2020/08/28/hexo使用方法/","link":"","permalink":"http://dongxin03.github.io/2020/08/28/hexo%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"","text":"hexo文档documentation 排除故障troubleshooting hexo githubGitHub. 新建文档1$ hexo new \"My New Post\" 更多信息: Writing 运行1$ hexo server 更多信息: Server 运行服务器1$ hexo generate 更多信息: Generating 部署到远程站点1$ hexo deploy 更多信息: Deployment","categories":[],"tags":[]},{"title":"mac笔记本的基本命令","slug":"mac笔记本基本命令","date":"2020-08-24T02:06:18.000Z","updated":"2020-08-28T00:15:44.000Z","comments":true,"path":"2020/08/24/mac笔记本基本命令/","link":"","permalink":"http://dongxin03.github.io/2020/08/24/mac%E7%AC%94%E8%AE%B0%E6%9C%AC%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/","excerpt":"","text":"1、 位置 驱动所在位置： /Systme/Library/Extensions 用户文件夹位置：/User/用户名，可以用波浪号(~)表示 桌面位置：/User/用户名/Desktop，可以用~/Desktop表示 2、清理 按天进行清理：sudo periodic daily 按每周进行清理：sudo periodic weekly 按每月进行清理：sudo periodic monthly 按上面3种情况进行清理：sudo periodic daily weekly monthly3、命令1、cd 进入文件夹2、ls 显示文件夹内容3、pwd 显示当前的目录路径4、ls -la 显示文件夹详细信息5、ls -A 显示文件夹内内容（包括.开头）6、mkdir 创建文件夹7、touch 创建文件8、mvdir 移动文件夹9、rm 删除文件或空文件夹10、rm -rf 删除非空文件夹11、rmdir 删除空文件夹12、cp 复制文件或文件夹13、find 使用匹配表达式查找文件14、open 使用默认程序打开文件15、cat 显示 文件内容16、ln 为文件创建连接17、head 显示文件的最初几行 head -20 file18、tail 显示文件的最后几行19、paste 横向拼接文件内容20、diff 比较并显示两个文件的内容差异21、wc 统计文件的字符数、词数和行数22、uniq 去掉文件中的重复行23、grep 通过简单正则表达式搜索文件 文件属性1- rw-r--r--@ 1 xz staff 42233727 7 19 16:30 powerBi.pbix 语法 属性 含义说明 - 文件类型 横杠表示普通文件，若为d表示文件夹 rw-r–r– 访问权限 分3组：用户、群组和其他用户的文件访问权限 1 文件数量 文件数量 xz 所在用户 用户 staff 所在群组 群组 42233727 文件大小 字节数（B） 7 9 16:30 修改日期 日期 常用操作 1、sudo 获取root sudo -s 2、control+D 或 exit 提出root 3、clear 清除屏幕或窗口内容 4、ping 发送回应请求 5、man 查看命令说明 man ls 6、which 查看指定程序的路径 which python 7、history 列出最近执行过的命令及编号 8、hostname 电脑在网络中的名称 9、env 显示当前所有设置过的环境变量 10、passwd 修改用户密码 11、date 显示系统的当前日期和时间 12、cal 显示日历 13、time 统计程序的执行时间 14、lsof -i tcp:4000 查看端口是否被占用 15、kill -9 PID 终止进程 快捷键 Command + Tab： 应用程序之间的切换 Command + Option + ←→：同一应用程序不同窗口切换 Command + H：隐藏窗口 Command + M：最小化窗口 Command + W：关闭页面窗口 Command + Q：关闭应用程序 Command + F3：显示桌面 Command + Shift + 4：截图插件 Command + Shift + 3：截当前屏幕 文本编辑常用快捷键 Fn + ↑ ：向上一页 Fn + ↓ ：向下一页 Fn + ←：文稿开头 Fn + →：文稿结尾 Command + ←：本行开头 Command + →：本行结尾 Option + ←：上一个单词末尾 Option + →：下一个单词末尾 Ctrl + A：段落开头 Command + C/V/X/A/S：复制/粘贴/剪切/全选/保存 Command + Shift + S：另存为 Command + Z：撤回 Command + Shift + Z：逆向撤回（前进） Xcode中常用的快捷键 Command + 0：打开/关闭导航器面板 Command + 1 ~ 8：对应导航器面板的各功能（Xcode左边栏的八项功能） Command + Shift + F：find，查找 Command + Shift + O：快速查找并跳转和打开 Command + Ctrl + ↑：.h、.m文件之间切换 Ctrl + 6：显示当前目录下的子文件或者当前文档的函数名称进行快速定位和切换 Command + R：不中断运行 Command + B：构建 Command + Shift + K：清除 Command + Shift + 0（zero）：打开文档与帮助 Option + 双击 ：跳转到鼠标对应类或方法的文档 Command + 单击：跳转到鼠标定位处的函数或类的定义处 Ctrl + 1：弹出View选择面板，可以选择查看当前类的父类、子类 、调用类和被调用类等详细信息 Command + Shift + Y：显示/隐藏调试区 Command + .（点）：停止调试器 Option + ←：上一个单词末尾 Option + →：下一个单词末尾 Command + Z：撤回 Command + Shift + Z：逆向撤回（前进","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"mac","slug":"mac","permalink":"http://dongxin03.github.io/tags/mac/"}]},{"title":"ES6ES7ES8","slug":"ES6ES7ES8","date":"2020-08-18T12:09:38.000Z","updated":"2020-09-01T02:44:12.000Z","comments":true,"path":"2020/08/18/ES6ES7ES8/","link":"","permalink":"http://dongxin03.github.io/2020/08/18/ES6ES7ES8/","excerpt":"","text":"ES61、let &amp; const &amp; 顶层对象 let 和var类似，但只在let命令所在的代码块内有效（没有变量提升）(暂时性死区)（不允许重复声明） 用let声明的变量，在声明之前使用都会报错 const 声明一个只读的常量，一旦声明，常量的值就不能改变。（不允许重复声明） 1234const foo = &#123;&#125;foo.a = 3; // 可以foo = &#123;a:3&#125;; // 不行 指向的地址不能改变// 可以使用Object.freeze(&#123;&#125;) 冻结对象 顶层对象 window global 1234var a = 1;window.a // 1let b == 2;window.b // undefined 2、结构赋值 数组的结构赋值本质上，只要等号两边的模式相同，左边的变量就会赋予对应的值。如果结构不能成，变量的值就等于undefined（如果等号右边不是数组将会报错）1234let [foo,[[bar],baz]] = [1,[[2],3]];foo // 1bar // 2baz // 3 可以给默认值12let [foo = &apos;a&apos;] = [];foo // &apos;a&apos; 对象的结构赋值变量必须与属性同名才能取到正确的值123let &#123;foo,baz&#125; = &#123;foo:&apos;a&apos;,bar:&apos;b&apos;&#125;;foo // &apos;a&apos;baz // undefined 也可以嵌套结构123456789let obj = &#123; p:[ &apos;a&apos;, &#123;y:&apos;b&apos;&#125; ]&#125;;let &#123;p:[foo,&#123;y&#125;]&#125; = obj;foo // &apos;a&apos;y // &apos;b&apos; 字符串的结构赋值123let [a,b,c,d,e] = &apos;hello&apos;;a // &apos;h&apos;b // &apos;e&apos; 也可以对属性结构赋值12let &#123;length : len&#125; = &apos;hello&apos;;length // 5 数值和布尔值的结构赋值如果等号右边的是数值和布尔，则会先转为对象1234let &#123;toString : s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString : s&#125; = true;s === Boolean.prototype.toString // true undefined 和 null 无法转为对象，所以对他们进行结构赋值会报错 函数参数的结构赋值123456function add([x,y])&#123; return x + y&#125;add([1,2]) // 3[[1,2],[3,4]].map(([a,b])=&gt;a+b) // [3,7] 结构赋值少使用圆括号，会报错* 3、字符串的 方法和扩展 方法 描述 anchor 创建一个 &lt;a name=&quot;传入的参数&quot;&gt;字符串&lt;/a&gt; big 创建一个&lt;big&gt;字符串&lt;/big&gt;大号字体显示 charAt 返回指定位置的字符 charCodeAt 返回指定位置的Unicode编码 concat 拼接字符串 fromCharCode 从字符编码创建一个字符串String.fromCharCode(102) == f indexOf 检索字符串 返回lin lastIndexOf 从后检索字符串 返回lin italics &lt;i&gt;字符串&lt;/i&gt; link &lt;a href=&quot;参数&quot;&gt;字符串&lt;/a&gt; localeCompare 用本地特定的顺序来比较两个字符串 match 正则表达式匹配 返回array replace 替换与正则表达式匹配的子串 search 检索与正则表达式相匹配的值 返回lin slice 提取字符串的片段，并在心的字符串中返回被提取的部分（截取） small &lt;small&gt;字符串&lt;/small&gt;小一号字体显示 split 把字符串分割为字符串数组 strike &lt;strike&gt;字符串&lt;/strike&gt; 删除线 sub &lt;sub&gt;字符串&lt;/sub&gt; 下标 sup &lt;sup&gt;字符串&lt;/sup&gt; 上标 substr 从第几个索引开始提取几个 substring 提取字符串中两个指定索引号之间的字符 toLocaleLowerCase 把字符串转换为小写 toLocaleUpperCase 把字符串转换为大些 toLowerCase 把字符串转换为小写 toUpperCase 把字符串转换为大些 toString 返回字符串 valueOf 返回某个字符串对象的原始值 字符的Unicode表示法 12345&apos;\\z&apos; === &apos;z&apos; // true&apos;\\172&apos; === &apos;z&apos; // true&apos;\\x7A&apos; === &apos;z&apos; // true&apos;\\u007A&apos; === &apos;z&apos; // true&apos;\\u&#123;7A&#125;&apos; === &apos;z&apos; // true 字符串的遍历器接口字符串可以被 for…of 循环遍历 123456for(let a of &apos;foo&apos;)&#123; console.log(a)&#125;// &apos;f&apos;// &apos;o&apos;// &apos;o&apos; 模板字符串 1let a = `$&#123;b&#125;eee`; .trim() 可以消除换行 4、正则 1、RegExp 构造函数 1234let regex = new RegExp(&apos;xyz&apos;,&apos;i&apos;)let regex = new RegExp(/xyz/,&apos;i&apos;)let regex = new RegExp(/xyz/i)let regex = new RegExp(/xyz/ig,&apos;i&apos;) // ig 会被第二个参数覆盖 2、字符串的正则方法 match replace search split 3、u 修饰符Unicode模式 （汉字的时候注意） /\\,/u //报错 4、RegExp.prototype.unicode是否设置了u修饰符； 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode // falser2.unicode // true 5、y 修饰符“粘连”修饰符y跟g一样，y修饰符确保匹配必须从第一位值开始g会忽略非法字符，y不会 6、RegExp.prototype.sticky是否这是了y修饰符 12let r = /hello/y;r.sticky // true 7、RegExp.prototype.flags 12/abc/ig.source // 返回正则表达式正文 &apos;abc&apos;/abc/.ig.flags // 返回正则表达式修饰符 &apos;ig&apos; 8、s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个 例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个 是行终止符（line terminator character）。 12/foo.bar/.test(&apos;foo\\nbar&apos;) // false/foo.bar/s.test(&apos;foo\\nbar&apos;) // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 1234const re = /foo.bar/s;re.test(&apos;foo\\nbar&apos;) // truere.dotAll // truere.flags // &apos;s&apos; 9、后行断言 10、Unicode 属性类 11、具名匹配正则表达式使用圆括号进行组匹配ES2018 引入类 具名匹配，允许每个组匹配质地ing一个名字，即便于阅读代码，又便于引用 12let re = /(?&lt;year&gt;\\d&#123;4&#125;)=(?&lt;month&gt;\\d&#123;2&#125;)-(?&lt;day&gt;\\d&#123;2&#125;)/u;&apos;2015-01-02&apos;.replace(re,&apos;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&apos;) // &apos;02/01/2015&apos; replace 方法的第二个参数也可以是函数 123456789101112&apos;2015-01-02&apos;.replace(re,( matched, // 整个匹配的结果 2015-01-02 capture1， // 第一个组匹配 2015 capture2，// 第二个组匹配 01 capture3， // 第三个组匹配 02 position， // 匹配开始的位置 0 s，// 原字符串 groups // 具名组构成的一个对象 &#123;year,month,day&#125;) =&gt; &#123; let &#123;day,month,year&#125; = groups; return `$&#123;day&#125;/$&#123;month/$&#123;year&#125;&#125;`&#125;) 12、正则匹配索引在exec（）方法的返回结果上加indices属性，在这个属性上面可以那道匹配开始位置和结束位置。 123456const text = &apos;zabbcdef&apos;;const re = /eb/;const result = re.exec(text);result.index // 1result.indices // [[1,3]] 每组开始结束的位置 13、 String.prototype.matchAll()ES2020 增加了 matchAll方法，可以一次性去除所有匹配。返回的是一个遍历器（Iterator），而不是数组。可以使用for…ofxunhuan取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 123456789const string = &apos;test1test2test3&apos;;const regex = /t(e)(st(\\d?))/g;for( const match of string.matchAll(regex))&#123; console.log(match)&#125;// [&apos;test1&apos;,&apos;e&apos;,&apos;st1&apos;,&apos;1&apos;,index:0,input:&apos;test1test2test3&apos;]// [&apos;test2&apos;,&apos;e&apos;,&apos;st2&apos;,&apos;1&apos;,index:5,input:&apos;test1test2test3&apos;]// [&apos;test3&apos;,&apos;e&apos;,&apos;st3&apos;,&apos;1&apos;,index:10,input:&apos;test1test2test3&apos;] 遍历器转为数组的方式非常简单，使用…运算符和Array.from（）方法就可以了12[...string.matchAll(regex)]Array.from(string.matchAll(regex)) 5、Number的方法和扩展 方法 描述 toString 把数字转换为字符串，使用指定的基数 toLocaleString 把数字转换为字符串，使用本地数字格式顺序 toFixed 把数字转换为字符串，结果的小数点后又自定位数的数字 toExponential 转换为指定的计数法（转为科学计数法 1.2 +2）参数-位数 1～20 toPrecision 把数字格式化为指定的长度（后面给加小数点） valueOf 返回一个Number对象的基本数字值 1、 二进制八进制表示法二进制前缀0b(或0B)八进制前缀0o(或0O) 120b11110111 === 503 // true0o767 === 503 // true 二进制和八进制转换十进制使用Number* 12Number(&apos;0b111&apos;) // 7Number(&apos;0o10&apos;) // 8 2、Number.isFinite(),Number.isNaN()Number.isFinite()用来检查数值是否为有限的（finite），即不是Infinity。 12345Number.isFinite(15) // trueNumber.isFinite(0.8) // trueNumber.isFinite(NaN) // falseNumber.isFinite(Infinity) // falseNumber.isFinite(&apos;foo&apos;) // false 参数不是数值，一律返回false Number.isNaN() 用来检查一个值是否为NaN 12345678Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN(&apos;15&apos;) // false 参数类型不是NaN 一律返回false ``` * 3、Number.parseInt()、Number.paresFloat()Es6将全局方法parseInt和paresFloat，移植到Number对象上面，行为完全保持不变* 4、Number.isInteger()`Number.isInteger()` 用来判断一个数值是否为整数 Number.isInteger(25) // trueNumber.isInteger(25.1) // falseNumber.isInteger(25.0) // trueNumber.isInteger(‘15’) // false 参数不是数值 返回falseNumber.isInteger(25.0) // true 12345678* 5、number.EPSILONes6在Number对象上面，新增一个极小的常量Number.EPSILON。根据规定它表示1与大于1的最小浮点数之间的差。* 6、安全整数和Number.isSafeInteger()javaScript能够准确表示整数范围在-2^53到2^53之间（不含两个端点）， 超过这个范围，无法精确表示这个值。`Number.isSafeInteger()`则是用来判断一个整数是否落在这个范围之内* 7、Math对象的扩展* 8、指数运算符ES2016 新增落一个指数运算符（**）。 2 ** 2 // 42 ** 3 // 8 1这个运算符的一个特点是右结右，多个指数运算符连用时，是从最右边开始计算的 // 相当于 2 ** （3 ** 2）2 ** 3 ** 2// 512 1指数运算符可以与等号结合，形成一个新的运算符（**=） let a = 1.5a *= 2// 等同于 a = a * a;let b = 4;b *= 3;// 等同于 b = b * b * b;``` 10、BigInt对象","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"web","slug":"web","permalink":"http://dongxin03.github.io/tags/web/"}]},{"title":"html5 到底新增了什么","slug":"html5到底新增了什么","date":"2020-08-16T02:52:04.000Z","updated":"2020-08-18T12:01:26.000Z","comments":true,"path":"2020/08/16/html5到底新增了什么/","link":"","permalink":"http://dongxin03.github.io/2020/08/16/html5%E5%88%B0%E5%BA%95%E6%96%B0%E5%A2%9E%E4%BA%86%E4%BB%80%E4%B9%88/","excerpt":"","text":"html5 到底新增了什么新增标签 &lt;template&gt; 通过javascript在运行时实例化内容的容器 &lt;section&gt; 定义文档中的一个章节 &lt;nav&gt; 定义只包含导航连接的章节 &lt;article&gt; 定义可以独立余内容其余部分的完整独立内容块 &lt;aside&gt; 定义和页面内容关联较低的内容——如果被删除，剩下的内容仍然很合理 &lt;header&gt; 定义页面或章节的头部。它经常包含logo、页面标题和导航性的目录 &lt;footer&gt; 定义页面或章节尾部。它经常包含版权信息、法律信息链接和反馈建议用的地址。 &lt;main&gt; 定义文档中主要或重要的内容 &lt;figure&gt; 代表一个和文档有关的图例 &lt;figcaption&gt; 代表一个图例的说明 &lt;time&gt; 代表日期和时间值；机器可读的等价形式通过datetime属性指定 &lt;mark&gt; 代表一段需要被高亮引用文字 &lt;ruby&gt; 代表被ruby注释标记的文本，如中文汉子和它的拼音 &lt;rt&gt; 代表ruby注释，如中文拼音 &lt;rp&gt; 代表ruby注释两边的额外插入文本，用于不支持ruby注释显示的浏览器中提供友好的注释显示 &lt;bdi&gt; 代表需要脱离父元素文本方向的一段文本。它允许嵌入一段不同或未知文本方向格式的文本 &lt;wbr&gt; 代表（建议）换行，当文本太长需要换行时将会在此处添加换行符号 &lt;embed&gt; 代表一个嵌入的外部资源，如应用程序或交互内容 &lt;video&gt; 代表一段视频及其视频文件和字幕，并提供了播放视频的用户界面 &lt;audio&gt; 代表一段声音，或音频流 &lt;source&gt; 为 video 或 audio 这类媒体元素指定媒体源 &lt;track&gt; 为 video 或 audio 这类媒体元素指定文本轨道（字幕） &lt;canvas&gt; 代表位图区域，可以通过脚本在它上面呈现图形，如图表，游戏绘图等 &lt;svg&gt; 定义一个嵌入式矢量图 &lt;math&gt; 定义一段数学公式 &lt;datalist&gt; 代表提供给其他控件的一组预定义选项 &lt;keygen&gt; 代表一个密钥对生成器控件 &lt;output&gt; 代表计算值 &lt;progress&gt; 代表进度条 &lt;meter&gt; 代表滑动条 &lt;details&gt; 代表一个用户可以（点击）获取额外信息或控件的小部件 &lt;summary&gt; 代表 details 元素的综述 或标题 &lt;menuitem&gt; 代表一个用户可以点击的菜单项 &lt;menu&gt; 代表菜单 通讯 web sockets 允许在页面和服务器之间建立持久连接并通过这种方法来交换非html数据（全双工通道，可以双向通讯） server-sent events 简称sse，允许服务器向客户端推送事件，而不是仅在响应客户端请求时服务器才能发送数据的传统范式（单向通道，只能服务器向浏览器发送） sse 使用http协议，现有的服务器软件都支持。webSocket是一个独立协议 sse属于轻量级，使用简单，webSocket 协议相对复杂 sse默认支持断线重连，webSocket需要自己实现 sse一般只用来传送文本，二进制数据需要编码后传送，webSocket默认支持传送二进制数据 支持自定义发送的消息类型 webRTC 这项技术，其中的RTC代表的是即时通信，允许连接到其他人，直接在浏览器中控制视频会议，而不需要一个插件或是外部的应用程序 离线 &amp; 存储 离线资源：应用程序缓存 （火狐）全面支持html5离线资源规范。其他大多数针对离线资源仅提供了某种程度上的支持 在线和离线事件 firefox3 支持WHATWG在线和离线事件，这可以让应用程序和扩展检测到是否存在可用的网络连接，以及在连接建立和断开时能感知到 WHATWG 客户端会话和持久化存储（又名DOM存储） 客户端会话和持久化存储让web应用程序能够在客户端存储结构化数据 indexedDB 是一个为了能够在浏览器中存储大量结构化数据，并且能够在这些数据上使用索引进行高性能检索的web标准 web应用程序中使用文件 对新的html5文件Api的支持已经被添加到Gecko中，从而使web应用程序可以访问用户选择的本地文件。这包括 type file 的input元素的新的multiple 属性针对多文件的选择支持。还有fileReader 多媒体 使用html5 音视频 audio 和video 元素嵌入并支持新的多媒体操作 使用camera API 允许使用，操作计算机摄像头，并从中存储图像 Track 和 WebVTT track 元素支持字幕和章节。webVTT一个文本轨迹格式 3D，图像 &amp; 效果 canvas WebGL WebGL通过引入了一套非常符合OpenGL ES2.0并且可以用在HTML5&lt;canvas&gt;元素中的api给Web带来了3D图像功能 svg 一个基于XML的可以直接嵌入到html中的矢量图格式 性能 &amp; 集成 Web Workers 能够把javaScript计算委托给后台线程，通过允许这些活动以防止使用交互型事件变得缓慢 XMLHttpRequest Level2 允许异步读取页面的某些部分，允许其显示动态内容，根据时间和用户行为而有所不同。这就是在Ajax背后的技术 即时编译javaScript引擎 新一代的javaScript 引擎功能更强大，性能更杰出 History API 允许对浏览器历史记录进行操作。这对那些交互的加载新信息的页面尤其有用 contentEditable属性：把你的网站变成wiki（多人协作的写作系统） html5 已经把contentEditable属性标准化了。 拖放 html5的拖放API能够支持网站内部和网站之间的拖放项目。同时也提供了一个更简单的供扩展和基于Mozilla （制作火狐的基金会）的应用程序使用的API html中的焦点管理 支持新的html5 activeElement和hasFocus属性。 基于Web的协议处理程序 你现在可以使用navigator.registerProtocolHandler() 方法把web应用程序注册成一个协议处理程序 requestAnimationFrame 允许控制动画渲染以获得更优性能 全屏API 为一个网页或者应用程序控制使用整个屏幕，而不是显示浏览器界面 指针锁定API 允许锁定到内容的指针，这样游戏或者类似应用程序在指针到达窗口限制时也不会失去焦点 在线和离线事件 为了构建一个良好的具有离线功能的web应用程序，你需要知道什么时候你的应用程序确实离线了。顺便提一句，在你的应用程序又再回到在线状态时你也需要知道。 设备访问 使用Camera API 允许使用和操作计算机的摄像头，并从中存取照片 触控事件 对用户按下触控屏幕的事件做出反应的处理程序 使用地理位置定位 让浏览器使用地理位置服务定位用户的位置 检测设备方向 让用户在运行浏览器的设备变更方向时能够得到信息。这可以被用作一种输入设备（例如制作能够对设备位置做出反应的游戏）或者使用页面的布局跟屏幕的方向相适应（横向或纵向）样式 新的背景样式特性 现在可以使用 box-shadow给逻辑框设置一个阴影，而且还可以设置 多背景。 更精美的边框 现在不仅可以使用图像来格式化边框，使用border-image和它关联的普通属性，而且可以通过border-radius属性来支持援交边框 为你的样式设置动画 使用css Transitions 以在不同状态间设置动画，或者使用css Animations在页面的某些部分设置动画而不需要一个触发事件，你现在可以在页面中控制移动元素来。 排版方面的改进 作者们如今又更强大的能力使自己的页面文字达到更佳的排版。他们不但可以控制text-overflow和hyphenation，还可以给它设置一个阴影或者更精细的控制它的decorations。感谢新的@font-face规则，现在我们可以下载并应用自定义的字体了 新的展示性布局 为了提高设计的灵活性，已经有两种新的布局被添加进来： css多栏布局，以及css 灵活方框布局 抄录-MDN","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"},{"name":"html5","slug":"技巧/html5","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/html5/"}],"tags":[{"name":"web","slug":"web","permalink":"http://dongxin03.github.io/tags/web/"}]},{"title":"焦灼的滚动条","slug":"滚动条整理","date":"2020-04-08T03:29:04.000Z","updated":"2020-05-08T05:10:35.000Z","comments":true,"path":"2020/04/08/滚动条整理/","link":"","permalink":"http://dongxin03.github.io/2020/04/08/%E6%BB%9A%E5%8A%A8%E6%9D%A1%E6%95%B4%E7%90%86/","excerpt":"","text":"让人焦灼的滚动条 还没写","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"web","slug":"web","permalink":"http://dongxin03.github.io/tags/web/"}]},{"title":"(Web)vue+声网-实现视频通话及调试","slug":"实现视频通话及调试","date":"2019-12-26T01:33:26.000Z","updated":"2019-12-26T02:35:17.000Z","comments":true,"path":"2019/12/26/实现视频通话及调试/","link":"","permalink":"http://dongxin03.github.io/2019/12/26/%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E9%80%9A%E8%AF%9D%E5%8F%8A%E8%B0%83%E8%AF%95/","excerpt":"","text":"都是官方文档，仅供我自己巩固 1、准出 有个项目 vue(别的项目也行 react啥的) 注册声网，在控制台创建个应用获取 appID(必须) 2、开始创建 这段代码是视频的时候，会将视频插入的dom，可以把这段dom放到你要视频的页面中； videoIdList 这个变量是我自己定义的，主要是存放远端视频（别人的视频）的id local_stream 这个元素id是我要插入本地视频的地方，也可以叫别的名字；（下面会讲） remote_video_ + 远端视频id ，这个元素id是我要插入远端视频的地方，也可以叫别的名字；（下面会讲） 注意 这两个最好包在一个id为video的元素下 不然总会插入到别的地方 （我也不会调 哈哈哈哈）*12345678910111213141516171819&lt;div id=&apos;video&apos; :style=&quot;&#123;height:&apos;100%&apos;,width:&apos;100%&apos;&#125;&quot;&gt; &lt;div class=&quot;video-view review-right-video&quot;&gt; &lt;div id=&quot;local_stream&quot; :style=&quot;&#123;height:&apos;100%&apos;,width:&apos;100%&apos;&#125;&quot;&gt;&lt;/div&gt; // 本地的视频会插入到这个ID下 &lt;div id=&quot;local_video_info&quot; class=&quot;video-profile hide&quot;&gt;&lt;/div&gt; &lt;div id=&quot;video_autoplay_local&quot; class=&quot;autoplay-fallback hide&quot;&gt;&lt;/div&gt; &lt;/div&gt; &lt;div v-for=&quot;item in videoIdList&quot; :key=&quot;item&quot; :id=&quot;`remote_video_panel_`+item&quot; // 远端的视频会插入到这个id 下 :class=&quot;[&apos;video-view review-center-video&apos;,imageUrl ? &apos;active&apos; : &apos;&apos;]&quot; &gt; &lt;div :style=&quot;&#123;height:&apos;100%&apos;,width:&apos;100%&apos;&#125;&quot; :id=&quot;`remote_video_`+item&quot; &gt;&lt;/div&gt; &lt;div :id=&quot;`remote_video_info_`+item&quot; class=&quot;video-profile hide&quot;&gt;&lt;/div&gt; &lt;div :id=&quot;`video_autoplay_`+item&quot; class=&quot;autoplay-fallback hide&quot;&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 3、对接声网 安装 npm install agora-rtc-sdk ; 也可以使用CDN CDN &lt;script src=&quot;https://cdn.agora.io/sdk/release/AgoraRTCSDK-3.0.0.js&quot;&gt;&lt;/script&gt;; 引入 import AgoraRTC from &#39;agora-rtc-sdk&#39;; 4、整个声网的文件*** 完整的代码在最下面，直接看代码就行 我建了一个文件 叫 agoraRTCfunct（都是网易翻译来的） 1.引入 sdkimport AgoraRTC from &#39;agora-rtc-sdk&#39;;2.设置两个参数变量主要的就是appID频道是自己定义的，就像设置一个房间，别人会根据你的频道号加入到你的视频当中 123456789101112131415const rtc = &#123; client: null, joined: false, //是否已经加入频道 published: false, // 是否已经发布 localStream: null, remoteStreams: [], params: &#123;&#125;&#125;;const option = &#123; appID: &quot;f3e69727bee94580be65eb6193a72b89&quot;, channel: &quot;123&quot;, // 频道 uid: 1123, // 用户id token: &quot;&quot; // 手机app上用的 没用&#125;; 3.开始声网 开始监听的代码在下面 ， 监听视频过程中的很多事件 创建本地流的代码也在下面 主要是创建了一个频道， 初始化一个频道 加入到这个频道 在页面中引入 import agora from ‘./agoraRTCfunct.js’; 创建的这个文件* thet是vue页面的this,我在页面初始化（mounted）的时候调用了 agora.agoraFunction(this); 传入了this* 因为有用户加入的时候会用到12345678910111213141516171819202122232425const agoraFunction = function(thet)&#123; if(rtc.joined)&#123; Notification.info(&quot;您已经加入频道&quot;); return; &#125;; // 创建客户端 rtc.client = AgoraRTC.createClient(&#123;mode: &quot;live&quot;, codec: &quot;vp8&quot;&#125;); rtc.params = &#123;mode:&apos;live&apos;, codec: &apos;vp8&apos;&#125;; // 赋值输入框的值 Listening(thet); // 开始监听 // 初始化 rtc.client.init(option.appID, function () &#123; console.log(&quot;初始化成功&quot;); //加入频道 rtc.client.join(option.token ? option.token : null, option.channel, option.uid ? +option.uid : null, function (uid) &#123; console.log(&quot;成功----频道号码: &quot; + option.channel + &quot;你的id: &quot; + uid); rtc.joined = true; rtc.params.uid = uid; // 获取到自己的id createStream(); // 创建本地流 &#125;, function(err) &#123; console.error(&quot;加入频道失败&quot;, err) &#125;) &#125;, (err) =&gt; &#123; console.error(err); &#125;); &#125;; 4.创建本地流（就是打开摄像头能看到自己）重要的是 rtc.localStream.play(‘local_stream’); // 插入到这个id中 local_stream 这个是我自己定义的ID 本地的视频会插入到这个元素中 发布本地流是把，本地的视频推到远端 、要不别人看不见12345678910111213141516171819const createStream = function()&#123; //创建本地流 // 创建本地流 rtc.localStream = AgoraRTC.createStream(&#123; streamID: rtc.params.uid, // 在上一步获取到的自己的视频id audio: true, video: true, screen: false, // 是不是需要共享屏幕 这个只在谷歌浏览器有用 不咋好使 &#125;); // 初始化本地流 rtc.localStream.setVideoProfile(&quot;360p_1&quot;); // 640X360 15 400 视频清晰度 rtc.localStream.init(function () &#123; console.log(&quot;本地流-初始化-成功&quot;,rtc.localStream); // 发布本地流 rtc.localStream.play(&apos;local_stream&apos;); // 插入到这个id中 publish(); // 发布本地流 &#125;, function (err) &#123; console.error(&quot;本地流-初始化-失败&quot;, err); &#125;);&#125; 发布根底流*123456789101112131415161718192021const publish = function () &#123; // 发布本地流 if (!rtc.client) &#123; Notification.info(&quot;您还没加入频道&quot;); return; &#125; if (rtc.published) &#123; Notification.info(&quot;您已经发布频道&quot;); return; &#125; const oldState = rtc.published; // publish localStream rtc.client.publish(rtc.localStream, function (err) &#123; rtc.published = oldState; console.log(&quot;publish failed&quot;); Toast.error(&quot;publish failed&quot;) console.error(err); &#125;) Notification.success(&quot;发布频道成功&quot;); rtc.published = true&#125; 5.监听视频过程中的事件 重要的是有别人加入你的视频中的事件（和离开） 主要是有用户加入频道的时候，要及时创建一个指定的对方id的元素* remoteStream.play(“remote_video_” + id); // 插入到 id为 remote_video_ + id 元素中 “remote_video_” + id 这个就是我定义的元素， 对方的视频会插入到这里1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586const Listening = function(thet)&#123; // 订阅事件 // ---- 订阅开始 rtc.client.on(&quot;error&quot;, (err) =&gt; &#123; console.log(&quot;===&gt;&quot;,err) &#125;); rtc.client.on(&quot;peer-leave&quot;, function(evt) &#123; // 有用户离开时 var uid = evt.uid; var reason = evt.reason; // 离线原因 Quit -- 主动离开 ServerTimeOut -- 超时掉线（也有可能是主动离开） if (uid != rtc.params.uid) &#123; thet.deleteView(uid); &#125;; Notification.info(&quot;用户离开&quot;); console.log(&quot;用户离线&quot; , uid, &quot;reason: &quot;, reason); &#125;); rtc.client.on(&quot;stream-published&quot;, function(evt)&#123; // 发布视频流本地触发 var remoteStream = evt.stream; var id = remoteStream.getId(); thet.myId = id; &#125;); rtc.client.on(&quot;stream-added&quot;, function (evt) &#123; //有远程流加入时 var remoteStream = evt.stream; var id = remoteStream.getId(); if (id !== rtc.params.uid) &#123; rtc.client.subscribe(remoteStream, function (err) &#123; // 订阅加入的远程端视频 console.log(&quot;订阅远程端视频失败&quot;, err); &#125;) &#125;; console.log(&apos;加入的远程端视频流: &apos;, id); &#125;); rtc.client.on(&quot;stream-subscribed&quot;, function (evt) &#123; //订阅远程流 var remoteStream = evt.stream; var id = remoteStream.getId(); rtc.remoteStreams.push(remoteStream); // 不知道干啥的 Notification.success(&quot;用户加入&quot;+id); thet.addView(id); setTimeout(()=&gt;&#123; // vue创建元素 是异步的 （一会处理） remoteStream.play(&quot;remote_video_&quot; + id); // 插入到 id为 remote_video_ + id 元素中 &#125;,300); console.log(&apos;接收到的远程端视频: &apos;, id); &#125;); rtc.client.on(&quot;stream-removed&quot;, function (evt) &#123; // 对方取消发布 var remoteStream = evt.stream; var id = remoteStream.getId(); remoteStream.stop(&quot;remote_video_&quot; + id); rtc.remoteStreams = rtc.remoteStreams.filter(function (stream) &#123; return stream.getId() !== id; &#125;) thet.deleteView(id); console.log(&apos;stream-removed remote-uid: &apos;, id); &#125;); rtc.client.on(&quot;onTokenPrivilegeWillExpire&quot;, function()&#123; // token过期前30秒调用 // client.renewToken(token); console.log(&quot;token即将过期&quot;) &#125;); rtc.client.on(&quot;onTokenPrivilegeDidExpire&quot;, function()&#123; // token已经失效 // client.renewToken(token); console.log(&quot;token已经失效&quot;); &#125;); rtc.client.on(&quot;network-quality&quot;, function(stats) &#123; // 本地用户的网络质量 console.log(&quot;下行&quot;, callQuality[stats.downlinkNetworkQuality]); console.log(&quot;上行&quot;, callQuality[stats.uplinkNetworkQuality]); &#125;); rtc.client.on(&quot;mute-audio&quot;, function(evt) &#123; // 对方关闭了语音 var uid = evt.uid; Notification.info(&quot;用户&quot;+uid+&quot;已静音&quot;); console.log(&quot;mute audio:&quot; + uid); //alert(&quot;mute audio:&quot; + uid); &#125;); rtc.client.on(&quot;unmute-audio&quot;, function (evt) &#123; // 对方打开了语音 var uid = evt.uid; Notification.info(&quot;用户&quot;+uid+&quot;打来了语音&quot;); console.log(&quot;unmute audio:&quot; + uid); &#125;); rtc.client.on(&quot;mute-video&quot;, function (evt) &#123; // 对方关闭摄像头 var uid = evt.uid; Notification.info(&quot;用户&quot;+uid+&quot;关闭了摄像头&quot;); console.log(&quot;mute video&quot; + uid); //alert(&quot;mute video:&quot; + uid); &#125;); rtc.client.on(&quot;unmute-video&quot;, function (evt) &#123; // 对方打开了摄像头 var uid = evt.uid; Notification.info(&quot;用户&quot;+uid+&quot;打开了了摄像头&quot;); console.log(&quot;unmute video:&quot; + uid); &#125;); // ---- 订阅结束&#125;; 我在监听到有用户加入的时候，把用户的id插入到一个数组里，循环渲染出了有特定id的元素（thet.addView(id);） 我在监听到有用户离开的时候，把用户的id从这个数组中去除掉，在循环渲染出了有特定id的元素（thet.deleteView(id);）123456789101112addView(id)&#123; if(id == this.myId || this.videoIdList.indexOf(id) != -1) return; const list = this.videoIdList; list.push(id); this.videoIdList = list;&#125;,deleteView(id)&#123; const index = this.videoIdList.indexOf(id); const list = this.videoIdList; list.splice(index,1); this.videoIdList = list;&#125;, 其他的就没有比较重要的了 导出了这几个方法123456789export default &#123; rtc, // 参数 option, // 参数 agoraFunction, // 声网开始的方法 创建 初始化 加入频道 publish, // 发布本地流 unpublish, // 停止发布本地流 leave, // 离开频道 getDevices, // 获取可用的 摄像头 麦克风&#125;; 完整的代码*123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286import AgoraRTC from &apos;agora-rtc-sdk&apos;;import &#123;Notification&#125; from &apos;element-ui&apos;;const callQuality = &#123; // 通话质量 0:&quot;质量未知&quot;, 1:&quot;质量极好&quot;, 2:&quot;用户主观感觉和极好差不多，但码率可能略低于极好&quot;, 3:&quot;用户主观感受有瑕疵但不影响沟通&quot;, 4:&quot;勉强能沟通但不顺畅&quot;, 5:&quot;网络质量非常差，基本不能沟通&quot;, 6:&quot;网络连接断开，完全无法沟通&quot;,&#125;const rtc = &#123; client: null, joined: false, //是否已经加入频道 published: false, // 是否已经发布 localStream: null, remoteStreams: [], params: &#123;&#125;&#125;;const option = &#123; appID: &quot;f3e69727bee94580be65eb6193a72b89&quot;, channel: &quot;123&quot;, // 频道 uid: 1123, // 用户id token: &quot;&quot; // 手机app上用的 没用&#125;;const leave = function () &#123; // 离开频道 if (!rtc.client) &#123; Notification.info(&quot;您还没加入频道&quot;); return; &#125; if (!rtc.joined) &#123; Notification.info(&quot;您还没加入频道(2)&quot;); return; &#125; rtc.client.leave(function () &#123; rtc.localStream.stop(); rtc.localStream.close(); while (rtc.remoteStreams.length &gt; 0) &#123; var stream = rtc.remoteStreams.shift(); var id = stream.getId(); stream.stop(); removeView(id); &#125; rtc.localStream = null; rtc.remoteStreams = []; rtc.client = null; rtc.published = false; rtc.joined = false; Notification.info(&quot;离开频道成功&quot;); &#125;, function (err) &#123; Notification.error(&quot;离开频道失败&quot;); console.error(err); &#125;)&#125;function unpublish (rtc) &#123; // 取消发布本地流 if (!rtc.client) &#123; Notification.info(&quot;您还没加入频道&quot;); return; &#125; if (!rtc.published) &#123; Toast.error(&quot;您已经发布频道&quot;); return; &#125; var oldState = rtc.published; rtc.client.unpublish(rtc.localStream, function (err) &#123; rtc.published = oldState; console.error(err); &#125;) Notification.info(&quot;取消发布成功&quot;); rtc.published = false;&#125;const createStream = function()&#123; //创建本地流 // 创建本地流 rtc.localStream = AgoraRTC.createStream(&#123; streamID: rtc.params.uid, audio: true, video: true, screen: false, &#125;); // 初始化本地流 rtc.localStream.setVideoProfile(&quot;360p_1&quot;); // 640X360 15 400 rtc.localStream.init(function () &#123; console.log(&quot;本地流-初始化-成功&quot;,rtc.localStream); // 发布本地流 rtc.localStream.play(&apos;local_stream&apos;); // 插入到这个id中 publish(); // 发布本地流 &#125;, function (err) &#123; console.error(&quot;本地流-初始化-失败&quot;, err); &#125;);&#125;const publish = function () &#123; // 发布本地流 if (!rtc.client) &#123; Notification.info(&quot;您还没加入频道&quot;); return; &#125; if (rtc.published) &#123; Notification.info(&quot;您已经发布频道&quot;); return; &#125; const oldState = rtc.published; // publish localStream rtc.client.publish(rtc.localStream, function (err) &#123; rtc.published = oldState; console.log(&quot;publish failed&quot;); Toast.error(&quot;publish failed&quot;) console.error(err); &#125;) Notification.success(&quot;发布频道成功&quot;); rtc.published = true&#125;const Listening = function(thet)&#123; // 订阅事件 // ---- 订阅开始 rtc.client.on(&quot;error&quot;, (err) =&gt; &#123; console.log(&quot;===&gt;&quot;,err) &#125;); rtc.client.on(&quot;peer-leave&quot;, function(evt) &#123; // 有用户离开时 var uid = evt.uid; var reason = evt.reason; // 离线原因 Quit -- 主动离开 ServerTimeOut -- 超时掉线（也有可能是主动离开） if (uid != rtc.params.uid) &#123; thet.deleteView(uid); &#125;; Notification.info(&quot;用户离开&quot;); console.log(&quot;用户离线&quot; , uid, &quot;reason: &quot;, reason); &#125;); rtc.client.on(&quot;stream-published&quot;, function(evt)&#123; // 发布视频流本地触发 var remoteStream = evt.stream; var id = remoteStream.getId(); thet.myId = id; &#125;); rtc.client.on(&quot;stream-added&quot;, function (evt) &#123; //有远程流加入时 var remoteStream = evt.stream; var id = remoteStream.getId(); if (id !== rtc.params.uid) &#123; rtc.client.subscribe(remoteStream, function (err) &#123; // 订阅加入的远程端视频 console.log(&quot;订阅远程端视频失败&quot;, err); &#125;) &#125;; console.log(&apos;加入的远程端视频流: &apos;, id); &#125;); rtc.client.on(&quot;stream-subscribed&quot;, function (evt) &#123; //订阅远程流 var remoteStream = evt.stream; var id = remoteStream.getId(); rtc.remoteStreams.push(remoteStream); // 不知道干啥的 Notification.success(&quot;用户加入&quot;+id); thet.addView(id); setTimeout(()=&gt;&#123; // vue创建元素 是异步的 （一会处理） remoteStream.play(&quot;remote_video_&quot; + id); // 插入到 id为 remote_video_ + id 元素中 &#125;,300); console.log(&apos;接收到的远程端视频: &apos;, id); &#125;); rtc.client.on(&quot;stream-removed&quot;, function (evt) &#123; // 对方取消发布 var remoteStream = evt.stream; var id = remoteStream.getId(); remoteStream.stop(&quot;remote_video_&quot; + id); rtc.remoteStreams = rtc.remoteStreams.filter(function (stream) &#123; return stream.getId() !== id; &#125;) thet.deleteView(id); console.log(&apos;stream-removed remote-uid: &apos;, id); &#125;); rtc.client.on(&quot;onTokenPrivilegeWillExpire&quot;, function()&#123; // token过期前30秒调用 // client.renewToken(token); console.log(&quot;token即将过期&quot;) &#125;); rtc.client.on(&quot;onTokenPrivilegeDidExpire&quot;, function()&#123; // token已经失效 // client.renewToken(token); console.log(&quot;token已经失效&quot;); &#125;); rtc.client.on(&quot;network-quality&quot;, function(stats) &#123; // 本地用户的网络质量 console.log(&quot;下行&quot;, callQuality[stats.downlinkNetworkQuality]); console.log(&quot;上行&quot;, callQuality[stats.uplinkNetworkQuality]); &#125;); rtc.client.on(&quot;mute-audio&quot;, function(evt) &#123; // 对方关闭了语音 var uid = evt.uid; Notification.info(&quot;用户&quot;+uid+&quot;已静音&quot;); console.log(&quot;mute audio:&quot; + uid); //alert(&quot;mute audio:&quot; + uid); &#125;); rtc.client.on(&quot;unmute-audio&quot;, function (evt) &#123; // 对方打开了语音 var uid = evt.uid; Notification.info(&quot;用户&quot;+uid+&quot;打来了语音&quot;); console.log(&quot;unmute audio:&quot; + uid); &#125;); rtc.client.on(&quot;mute-video&quot;, function (evt) &#123; // 对方关闭摄像头 var uid = evt.uid; Notification.info(&quot;用户&quot;+uid+&quot;关闭了摄像头&quot;); console.log(&quot;mute video&quot; + uid); //alert(&quot;mute video:&quot; + uid); &#125;); rtc.client.on(&quot;unmute-video&quot;, function (evt) &#123; // 对方打开了摄像头 var uid = evt.uid; Notification.info(&quot;用户&quot;+uid+&quot;打开了了摄像头&quot;); console.log(&quot;unmute video:&quot; + uid); &#125;); // ---- 订阅结束&#125;;// 开始声网const agoraFunction = function(thet)&#123; // 创建客户端 if(rtc.joined)&#123; Notification.info(&quot;您已经加入频道&quot;); return; &#125;; rtc.client = AgoraRTC.createClient(&#123;mode: &quot;live&quot;, codec: &quot;vp8&quot;&#125;); rtc.params = &#123;mode:&apos;live&apos;, codec: &apos;vp8&apos;&#125;; // 赋值输入框的值 Listening(thet); // 开始监听 // 初始化 rtc.client.init(option.appID, function () &#123; console.log(&quot;初始化成功&quot;); //加入频道 rtc.client.join(option.token ? option.token : null, option.channel, option.uid ? +option.uid : null, function (uid) &#123; console.log(&quot;成功----频道号码: &quot; + option.channel + &quot;你的id: &quot; + uid); rtc.joined = true; rtc.params.uid = uid; createStream(); // 创建本地流 &#125;, function(err) &#123; console.error(&quot;加入频道失败&quot;, err) &#125;) &#125;, (err) =&gt; &#123; console.error(err); &#125;); &#125;;const getDevices = function (next) &#123; // 获取音视频设备信息 AgoraRTC.getDevices(function (items) &#123; items.filter(function (item) &#123; return [&apos;audioinput&apos;, &apos;videoinput&apos;].indexOf(item.kind) !== -1 &#125;).map(function (item) &#123; return &#123; name: item.label, value: item.deviceId, kind: item.kind, &#125; &#125;); var videos = []; var audios = []; for (var i = 0; i &lt; items.length; i++) &#123; var item = items[i]; if (&apos;videoinput&apos; == item.kind) &#123; var name = item.label; var value = item.deviceId; if (!name) &#123; name = &quot;camera-&quot; + videos.length; &#125; videos.push(&#123; name: name, value: value, kind: item.kind &#125;); &#125; if (&apos;audioinput&apos; == item.kind) &#123; var name = item.label; var value = item.deviceId; if (!name) &#123; name = &quot;microphone-&quot; + audios.length; &#125; audios.push(&#123; name: name, value: value, kind: item.kind &#125;); &#125; &#125; console.log(&#123;videos: videos, audios: audios&#125;); // next(&#123;videos: videos, audios: audios&#125;); &#125;);&#125;export default &#123; rtc, // 参数 option, // 参数 agoraFunction, // 声网开始的方法 publish, // 发布本地流 unpublish, // 停止发布本地流 leave, // 离开频道 getDevices, // 获取可用的 摄像头 麦克风&#125;; 到此结束","categories":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/categories/vue/"},{"name":"声网","slug":"vue/声网","permalink":"http://dongxin03.github.io/categories/vue/%E5%A3%B0%E7%BD%91/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/tags/vue/"},{"name":"声网","slug":"声网","permalink":"http://dongxin03.github.io/tags/%E5%A3%B0%E7%BD%91/"}]},{"title":"webSocket用法","slug":"webSocket用法","date":"2019-12-16T01:48:27.000Z","updated":"2019-12-16T01:53:30.000Z","comments":true,"path":"2019/12/16/webSocket用法/","link":"","permalink":"http://dongxin03.github.io/2019/12/16/webSocket%E7%94%A8%E6%B3%95/","excerpt":"","text":"在长时间连接，没有通讯时，实际情况可能会出现断连，所以要设置心跳包 12345678910111213141516171819202122232425262728293031initSocket() &#123; // 初始化webSocket let url = `ws://xxxxxxx`; this.webSocket = new WebSocket(url) this.webSocket.onopen = this.webSocketOnOpen this.webSocket.onclose = this.webSocketOnClose this.webSocket.onmessage = this.webSocketOnMessage this.webSocket.onerror = this.webSocketOnError&#125;,webSocketOnOpen() &#123; // 连接成功 Notification.success(&quot;已连接，等待接入。&quot;) console.log(&apos;websocket连接成功&apos;); this.webHeart = setInterval(()=&gt;&#123; // webSoket 心跳包 this.webSocket.send(&quot;心跳包&quot;); &#125;,60000)&#125;,webSocketOnMessage(res) &#123; // 等待接收数据 console.log(&apos;===res=================================&apos;); console.log(res); console.log(&apos;====================================&apos;);&#125;,webSocketOnClose() &#123; // 连接关闭 this.socketClose = true; clearInterval(this.webHeart); // 清除心跳包 console.log(&apos;websocket连接已关闭&apos;);&#125;,webSocketOnError(res) &#123; // 连接失败 if(this.webHeart)&#123; clearInterval(this.webHeart); // 清除心跳包 &#125;; console.log(&apos;websocket连接失败&apos;);&#125;,","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"webSocket","slug":"webSocket","permalink":"http://dongxin03.github.io/tags/webSocket/"}]},{"title":"webSocket和https的问题","slug":"webSocket和https的问题","date":"2019-12-13T07:54:03.000Z","updated":"2019-12-13T08:06:18.000Z","comments":true,"path":"2019/12/13/webSocket和https的问题/","link":"","permalink":"http://dongxin03.github.io/2019/12/13/webSocket%E5%92%8Chttps%E7%9A%84%E9%97%AE%E9%A2%98/","excerpt":"","text":"webSocket 与 https 报错 如果网站使用HTTPS，WebSocket必须要使用wss协议； 使用wss协议的连接请求必须只能写域名，而非IP+端口； 建议在URL域名后面为websocket定义一个路径，本例中是/wss/； nginx 配置 前提是要配置好HTTPS，只需要在HTTPS配置的server内加一个location即可；123456789# websocketslocation /wss/ &#123; proxy_pass http://xxx.xx.xx.xx:8006; proxy_http_version 1.1; proxy_set_header Upgrade $http_upgrade; proxy_set_header Connection &quot;Upgrade&quot;; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header X-Real-IP $remote_addr;&#125; 注意： 1、location /wss/ {…}这里要格外注意！ html中的url是 wss://www.xxx.cn/wss/，所以Nginx配置中一定要是 /wss/如果前端是 wss://www.xxx.cn/wss，Nginx对应是 /wss 2、proxy_pass对应的最好是公网IP加端口号，我试过 ‘localhost’，’127.0.0.1’，域名都会失败 3、proxy_http_version 1.1 版本号必须是1.1，这条配置必需 说明： Nginx反向代理，无论是HTTP/S或是WebSocket都会走443端口，由Nginx分发给各个项目服务器。在我的项目中WebSocket服务器是独立于Django的，监听端口为8006。","categories":[{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/categories/%E6%8A%80%E5%B7%A7/"}],"tags":[{"name":"webSocket","slug":"webSocket","permalink":"http://dongxin03.github.io/tags/webSocket/"},{"name":"https","slug":"https","permalink":"http://dongxin03.github.io/tags/https/"}]},{"title":"react+electron搭建七牛云上传图片桌面端","slug":"react+electron搭建七牛云上传图片桌面端","date":"2019-11-28T08:35:57.000Z","updated":"2019-11-29T09:30:36.000Z","comments":true,"path":"2019/11/28/react+electron搭建七牛云上传图片桌面端/","link":"","permalink":"http://dongxin03.github.io/2019/11/28/react+electron%E6%90%AD%E5%BB%BA%E4%B8%83%E7%89%9B%E4%BA%91%E4%B8%8A%E4%BC%A0%E5%9B%BE%E7%89%87%E6%A1%8C%E9%9D%A2%E7%AB%AF/","excerpt":"","text":"咋想的 每次上传图到七牛云，都需要登录七牛云找到仓库，上传。步骤有些繁琐。所以自己做个上传的小工具。 自己画的原型图————简单、明了、好看步骤 1、拖拽和选择图片，获取图片信息 2、获取上传token 3、点击上传 4、包装electron—— 简简单单的四步 搭建 1、create-react-app image-updata搭建一个名字为image-updata的项目 这一步有必要且先执行这一步 这时候yarn start就可以看到react页面里 2、yarn eject || npm run eject 可以显示出webpack配置文件 （修改了启动端口，默认3000 —— 不改也行，修改了静态文件打包路径，改成了相对路径 –不改也行。。。） 修改启动端口 修改scripts/start.js 的DEFAULT_PORT （scripts文件夹没有？执行yarn eject） 修改静态文件打包路径 在yarn build 的时候build文件夹下的index.html里引入文件都用的是绝对路径，会找不到，—所以可以修改打包路径 修改config/paths.js 的 getServedPage方法里的 servedUrl这块’/‘改成’./‘ 在执行yarn eject之后可能会报错，一般是缺少包，缺啥补啥就好*yarn add @babel/helper-create-regexp-features-plugin 开始写页面 这里就比较简单，就一个页面所以把App.js改改就好 一开始是这样的 简单改改之后(结构就这样的)123456789101112131415161718192021222324252627282930313233 &lt;div className=&quot;App&quot;&gt; &lt;div className=&quot;content&quot; key=&quot;content&quot;&gt; &lt;div className=&quot;set-button&quot;&gt; &lt;span onClick=&#123;()=&gt;&#123;&#125;&#125;&gt;上传&lt;/span&gt; &lt;/div&gt; &lt;div className=&quot;select-content&quot;&gt; &lt;div className=&quot;into&quot;&gt; &lt;ul&gt; &lt;li&gt;图片名称&lt;/li&gt; &lt;/ul&gt; &lt;p&gt;将图片拖入&lt;/p&gt; &lt;p style=&#123;&#123;marginTop:&apos;30px&apos;,paddingTop:0&#125;&#125;&gt;100%&lt;/p&gt; &lt;p style=&#123;&#123;marginTop:&apos;30px&apos;,paddingTop:0&#125;&#125;&gt;提示文字&lt;/p&gt; &lt;/div&gt; &lt;div className=&quot;select-image-button&quot;&gt; &lt;input className=&quot;iamge-file&quot; type=&quot;file&quot; onChange=&#123;()=&gt;&#123;&#125;&#125;/&gt; &lt;span&gt;选择图片&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div className=&quot;updata-url&quot; key=&quot;updata-url&quot;&gt; &lt;p&gt;图片url:&lt;/p&gt; &lt;p className=&quot;image-url&quot;&gt;图片地址&lt;/p&gt; &lt;p className=&quot;copy&quot; onClick=&#123;this.urlCopy&#125;&gt;点击复制&lt;/p&gt; &lt;input className=&quot;copy_content&quot; type=&quot;text&quot; value=&quot;&quot; onChange=&#123;()=&gt;&#123;&#125;&#125; style=&#123;&#123;position: &apos;absolute&apos;,&apos;top&apos;:0,&apos;left&apos;: 0,&apos;opacity&apos;: 0,&apos;zIndex&apos;:&apos;-10&apos;&#125;&#125; /&gt; &lt;/div&gt;&lt;/div&gt; 样式修改App.css,我就不多说了 这时候的页面 开始步骤 1 拖拽和选择图片获取图片信息 1、拖拽图片放下的时候获取图片信息1234567891011121314151617181920212223242526272829pullImageFunct()&#123; // 拖拽图片获取 this.dropEle = document.querySelector(&apos;.into&apos;); // 监听的鼠标放下区域 const thse = this; this.dropEle.addEventListener(&quot;dragenter&quot;, function (e) &#123; //文件拖拽进 e.preventDefault(); e.stopPropagation(); &#125;, false); this.dropEle.addEventListener(&quot;dragover&quot;, function (e) &#123; //文件拖拽在悬浮 e.preventDefault(); e.stopPropagation(); &#125;, false); this.dropEle.addEventListener(&quot;dragleave&quot;, function (e) &#123;//文件拖拽离开 e.preventDefault(); e.stopPropagation(); &#125;, false); this.dropEle.addEventListener(&quot;drop&quot;, function (e) &#123;//文件拖拽放下 e.preventDefault(); e.stopPropagation(); // 处理拖拽文件的逻辑 var df = e.dataTransfer; for(var i = 0; i &lt; df.items.length; i++) &#123; var item = df.items[i]; if(item.kind === &quot;file&quot; &amp;&amp; item.webkitGetAsEntry().isFile) &#123; var file = item.getAsFile(); thse.setImageInfo(file); // 统一设置文件信息 &#125; &#125; &#125;);&#125; 要禁止拖进、悬浮、拖出事件，否则会跳转123componentDidMount()&#123; this.pullImageFunct();&#125; 拖拽事件需要监听 2、文件选择12345678inputFunct(e)&#123; // 选择图片 const path = e.target.files[0][&apos;path&apos;]; // 文件路径 const type = e.target.files[0][&apos;type&apos;]; // 正则去文件名字 /.*\\/([^\\/]+)\\..+/ const rgx = /.*\\/([^\\/]+)/; const name = rgx.exec(path)[1]; this.setImageInfo(&#123;path,name,type&#125;) // 统一设置文件信息&#125; 需要在input的change事件执行 统一设置文件信息12345678setImageInfo(info)&#123; // 设置上传参数 this.setState(&#123; imagePath:info.path, selectImgName:info.name, imageType:info.type, showMessage:false, &#125;)&#125; 这个时候就可以拿到文件的path、type、name。第一步完成 开始步骤 2 获取上传token 七牛上传的时候需要token，获取tokan，需要accessKey，secretKey，都可以在七牛找到可以在密钥管理中找到 获取tokenyarn add qiniu 安装qnniu 1234567891011121314151617181920import nodeQiniu from &apos;qiniu&apos;;const accessKey = &apos;&apos;; // 你的密钥const secretKey = &apos;&apos;; // 你的密钥getToKen()&#123; // 获取token return new Promise((res,rej)=&gt;&#123; const bucket = &apos;image_list&apos;; // 这是你的图片仓库名 let mac = new nodeQiniu.auth.digest.Mac(accessKey, secretKey); let options = &#123; scope: bucket, expires: 3600 * 24 // 密钥过期时间 &#125;; let putPolicy = new nodeQiniu.rs.PutPolicy(options); let uploadToken= putPolicy.uploadToken(mac); if(uploadToken)&#123; res(uploadToken); // 你的上传token &#125;else&#123; rej(); &#125; &#125;);&#125; 这是好你的密钥和图片仓库名，就可以拿到密钥 开始步骤 3 上传图片qiniu.upload 是七牛上传图片的api，需要blob格式的图片图片设置blob,在点击上传click执行 1234567891011121314151617181920212223imageBlob()&#123; //获取图片 blob const ther = this; const &#123;imagePath&#125; = this.state; //文件路径 if(!imagePath)&#123; this.setState(&#123; showMessage:true, message:&apos;未获取到图片&apos; &#125;) return; &#125; const xhr = new XMLHttpRequest(); // ajax请求图片 xhr.open(&quot;get&quot;, `file://$&#123;imagePath&#125;`, true); xhr.responseType = &quot;blob&quot;; xhr.onload = async function () &#123; if (this.status === 200) &#123; //得到一个blob对象 var blob = this.response; // 图片blob const token = await ther.getToKen(); // 获取token ther.imageUpData(&#123;token,blob&#125;) // 上传图片 &#125; &#125; xhr.send();&#125; 上传yarn add qiniu-js 安装 123456789101112131415161718192021222324252627282930313233343536373839404142imageUpData(&#123;token,blob&#125;)&#123; // 上传图片 token,blob const &#123;selectImgName,imageType&#125; = this.state; //图片名称和图片type const ther = this; const putExtra = &#123; // 上传需要的参数 fname: &quot;&quot;, params: &#123;&#125;, mimeType: [imageType] &#125;; const config = &#123; // 上传需要的参数 useCdnDomain: true, region: qiniu.region.z2 &#125;; const observable = qiniu.upload(blob,selectImgName,token,putExtra,config); observable.subscribe(&#123; next(res)&#123; ther.setState(&#123; progress:res.total.percent.toFixed(2) // 进度 &#125;) &#125;, error(err)&#123; // 失败 if(err.code == 401)&#123; ther.setState(&#123; showMessage:true, message:&apos;密钥错误，检查密钥&apos; &#125;) &#125;else&#123; ther.setState(&#123; showMessage:true, message:err.message &#125;) &#125; &#125;, complete(res)&#123; // 成功 ther.setState(&#123; loadUrl:res.key, progress:0, isSuccess:true, message:&apos;成功--点击下方复制url&apos; &#125;) &#125; &#125;)&#125; 这时候就可以上传图片了 点击复制 需要设置个图片仓库中使用的域名123456789const host = &apos;&apos;; //你的图片仓库使用的域名 urlCopy()&#123; //点击复制url const &#123;loadUrl&#125; = this.state; // 上传后返回的路径 const inputElement = document.querySelector(&apos;.copy_content&apos;); // 点击复制只能在input上 inputElement.value = host+loadUrl; inputElement.select(); // 必须 document.execCommand(&quot;Copy&quot;); // 浏览器提供 global.alert(&apos;复制成功&apos;); &#125; 开始步骤 4 包装electronnpm install electron --save-dev 安装 这一步会很慢，可以转taobao的源 在根目录创建 main.js 和 renderer.js main.js 本地测试注意端口号12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061const &#123; app, BrowserWindow &#125; = require(&apos;electron&apos;);const path = require(&apos;path&apos;);let mainWindow = null;//判断命令行脚本的第二参数是否含--debugconst debug = /--debug/.test(process.argv[2]);function makeSingleInstance () &#123; if (process.mas) return; app.requestSingleInstanceLock(); app.on(&apos;second-instance&apos;, () =&gt; &#123; if (mainWindow) &#123; if (mainWindow.isMinimized()) mainWindow.restore() mainWindow.focus() &#125; &#125;)&#125;function createWindow () &#123; mainWindow = new BrowserWindow(&#123; width: 300, height: 500, webPreferences: &#123; javascript: true, plugins: true, nodeIntegration: true, // 是否集成 Nodejs webSecurity: false, preload: path.join(__dirname, &apos;./renderer.js&apos;) // 但预加载的 js 文件内仍可以使用 Nodejs 的 API &#125; &#125;) mainWindow.loadURL(&quot;http://localhost:8403/&quot;); //本地测试注意端口号 // mainWindow.loadURL(path.join(&apos;file://&apos;,__dirname,&apos;/build/index.html&apos;)); //打包使用 //接收渲染进程的信息 const ipc = require(&apos;electron&apos;).ipcMain; ipc.on(&apos;min&apos;, function () &#123; mainWindow.minimize(); &#125;); ipc.on(&apos;max&apos;, function () &#123; mainWindow.maximize(); &#125;); ipc.on(&quot;login&quot;,function () &#123; mainWindow.maximize(); &#125;); mainWindow.on(&apos;closed&apos;, () =&gt; &#123; mainWindow = null &#125;)&#125;makeSingleInstance();//app主进程的事件和方法app.on(&apos;ready&apos;, () =&gt; &#123; createWindow();&#125;);app.on(&apos;window-all-closed&apos;, () =&gt; &#123; if (process.platform !== &apos;darwin&apos;) &#123; app.quit() &#125;&#125;);app.on(&apos;activate&apos;, () =&gt; &#123; if (mainWindow === null) &#123; createWindow(); &#125;&#125;);module.exports = mainWindow; renderer.js 必须1global.electron = require(&apos;electron&apos;); 修改package.json* 添加main.js 设置启动命令&quot;start&quot;: &quot;node scripts/start.js | electron . --debug&quot;, 这个时候关闭服务，在启动服务yarn start，就可以在electron中启动了*有时候会出现端口占用的情况**mac 可以 lsof -i :端口号 看端口占中 kill -9 PID 关闭进程** 最后一步打包npm install electron-packager --save-dev 安装electron 打包工具 package.json 添加打包命令&quot;package&quot;: &quot;electron-packager ./&quot; 修改main.js中的mainWindow.loadURLmainWindow.loadURL(path.join(&#39;file://&#39;,__dirname,&#39;/build/index.html&#39;)) 执行 yarn package 会在根目录创建一个打包文件可以直接使用 可以修改yarn package命令定制打包名称、地址、打包系统、图标 什么都没设置会根据本地系统生成打包文件（我在mac上可以） github位置 到此结束","categories":[{"name":"react","slug":"react","permalink":"http://dongxin03.github.io/categories/react/"},{"name":"七牛云","slug":"react/七牛云","permalink":"http://dongxin03.github.io/categories/react/%E4%B8%83%E7%89%9B%E4%BA%91/"}],"tags":[{"name":"react","slug":"react","permalink":"http://dongxin03.github.io/tags/react/"},{"name":"election","slug":"election","permalink":"http://dongxin03.github.io/tags/election/"}]},{"title":"vue 6、api盲点","slug":"vue 6、api盲点","date":"2019-11-25T08:20:33.000Z","updated":"2019-11-25T08:14:35.000Z","comments":true,"path":"2019/11/25/vue 6、api盲点/","link":"","permalink":"http://dongxin03.github.io/2019/11/25/vue%206%E3%80%81api%E7%9B%B2%E7%82%B9/","excerpt":"","text":"使用performance开启性能追踪123if (process.env.NODE_ENV !== &apos;production&apos;) &#123; Vue.config.performance = true;&#125; 是开发环境的时候开启 开启后我们可以下载 Vue Performance Devtool 这一 chrome 插件来看查看各个组件的加载情况使用errorHandler 来捕获异常123456789Vue.config.errorHandler = function (err, vm, info) &#123; let &#123; message, // 异常信息 name, // 异常名称 stack // 异常堆栈信息 &#125; = err; // vm 为抛出异常的 Vue 实例 // info 为 Vue 特定的错误信息，比如错误所在的生命周期钩子&#125; 在入口文件中加入上述代码后，我们便可以捕获到 Vue 项目中的一些异常信息了，但是需要注意的是 Vue 2.4.0 起的版本才支持捕获 Vue 自定义事件处理函数内部的错误使用nextTick将回调延迟到下次DOM更新循环之后执行123456789101112131415161718192021222324&lt;template&gt; &lt;ul ref=&quot;box&quot;&gt; &lt;li v-for=&quot;(item, index) in arr&quot; :key=&quot;index&quot;&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/template&gt;&lt;script&gt;export default &#123; data() &#123; return &#123; arr: [] &#125; &#125;, mounted() &#123; this.getData(); &#125;, methods: &#123; getData() &#123; this.arr = [1, 2, 3]; this.$refs.box.getElementsByTagName(&apos;li&apos;)[0].innerHTML = &apos;hello&apos;; &#125; &#125;&#125;&lt;/script&gt; 在DOM元素li还未渲染就调用会报错 可以将方法放到nextTick回调中123this.$nextTick(() =&gt; &#123; this.$refs.box.getElementsByTagName(&apos;li&apos;)[0].innerHTML = &apos;hello&apos;;&#125;) 也可以使用async/await123456789methods: &#123; async getData() &#123; this.arr = [1, 2, 3]; await this.$nextTick(); this.$refs.box.getElementsByTagName(&apos;li&apos;)[0].innerHTML = &apos;hello&apos;; &#125;&#125; 对低开销的静态组件使用v-once v-once指令用于只渲染元素和组件一次 一般可以用于存在大量静态数据组件的更新性能优化1&lt;my-component v-once :data=&quot;msg&quot;&gt;&lt;/my-component&gt; msg 的值如何变化，组件内渲染的永远是其第一次获取到的初始值。 使用$isServer判断当前实例是否运行与服务器 使用$isServer则无需进行配置，在组件中直接使用API即可123if (this.$isServer) &#123; document.title = &apos;test&apos;;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/tags/vue/"},{"name":"api","slug":"api","permalink":"http://dongxin03.github.io/tags/api/"}]},{"title":"vue 4、编码技巧与规范","slug":"vue 5、编码技巧与规范","date":"2019-11-25T08:19:33.000Z","updated":"2019-11-25T08:13:03.000Z","comments":true,"path":"2019/11/25/vue 5、编码技巧与规范/","link":"","permalink":"http://dongxin03.github.io/2019/11/25/vue%205%E3%80%81%E7%BC%96%E7%A0%81%E6%8A%80%E5%B7%A7%E4%B8%8E%E8%A7%84%E8%8C%83/","excerpt":"","text":"使用对象代替 if 及 switch12345678let name = &apos;lisi&apos;;let obj = &#123; zhangsan: 21, lisi: 18, wangwu: 12&#125;;let age = obj[name] || 18; 判断过后有较多处理逻辑的还需要使用if或者switch使用Array.from 快速生成数组1let hours = Array.from(&#123; length: 24 &#125;, (value, index) =&gt; index + &apos;时&apos;); 使用router.beforeEach处理跳转前逻辑12345678910111213141516171819202122232425262728293031323334353637383940414243444546import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;Vue.use(Router)// 首页const Home = (resolve =&gt; &#123; require.ensure([&apos;../views/home.vue&apos;], () =&gt; &#123; resolve(require(&apos;../views/home.vue&apos;)) &#125;)&#125;)let base = `$&#123;process.env.BASE_URL&#125;`;let router = new Router(&#123; mode: &apos;history&apos;, base: base, routes: [ &#123; path: &apos;/&apos;, name: &apos;home&apos;, component: Home, meta: &#123; title: &apos;首页&apos; &#125; &#125;, ]&#125;)router.beforeEach((to, from, next) =&gt; &#123; let title = to.meta &amp;&amp; to.meta.title; if (title) &#123; document.title = title; // 设置页面 title &#125; if (to.name === &apos;home&apos;) &#123; // 拦截并跳转至 page2 单页，$openRouter 方法在第 5 节中封装 Vue.$openRouter(&#123; name: &apos;page2&apos; &#125;); &#125; next();&#125;)export default router 注意最后需要调用next()方法执行路由跳转*路由跳转尽量使用name而不是path12345678this.$router.push(&#123; name: &apos;page1&apos;&#125;);// 而不是this.$router.push(&#123; path: &apos;page1&apos;&#125;); 循环渲染添加 v-bind:key || :key (尽量使用id而不是index) 因为如果在数组中间插入值，其之后的index会发生该拜年，即使数据没变Vue也会进行重新渲染； 使用computed代替watch watch:当监测的属性变化时会自动执行对应的回调函数 computed: 计算属性只有在它的相关依赖发生改变时才会重新求值统一管理缓存变量 使用整合的常量管理 types.js 使用setTimeout 代替 setInterval不要使用for in 循环遍历数组 其会遍历数组原型链上的属性123456789101112let arr = [1, 2];for (let key in arr) &#123; console.log(arr[key]); // 会正常打印 1, 2&#125;// 但是如果在 Array 原型链上添加一个方法Array.prototype.test = function() &#123;&#125;;for (let key in arr) &#123; console.log(arr[key]); // 此时会打印 1, 2, ƒ () &#123;&#125;&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/tags/vue/"},{"name":"技巧","slug":"技巧","permalink":"http://dongxin03.github.io/tags/%E6%8A%80%E5%B7%A7/"}]},{"title":"vue 4、项目整合与优化","slug":"vue 4、项目整合与优化","date":"2019-11-25T08:15:33.000Z","updated":"2019-11-25T08:10:55.000Z","comments":true,"path":"2019/11/25/vue 4、项目整合与优化/","link":"","permalink":"http://dongxin03.github.io/2019/11/25/vue%204%E3%80%81%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%E4%B8%8E%E4%BC%98%E5%8C%96/","excerpt":"","text":"使用alias简化路径 在原声webpack配置中我们可以定义alias来简化路径123456789101112131415161718192021const path = require(&apos;path&apos;)const resolve = dir =&gt; &#123; return path.join(__dirname, dir)&#125;module.exports = &#123; ... resolve: &#123; alias: &#123; &apos;@&apos;: resolve(&apos;src&apos;), // 定义 src 目录变量 _lib: resolve(&apos;src/common&apos;), // 定义 common 目录变量, _com: resolve(&apos;src/components&apos;), // 定义 components 目录变量, _img: resolve(&apos;src/images&apos;), // 定义 images 目录变量, _ser: resolve(&apos;src/services&apos;), // 定义 services 目录变量, &#125; &#125;, ...&#125; 在vue-cli 3.x中我们需要处理vue.config.js chainWebpack123456789101112131415/* vue.config.js */module.exports = &#123; ... chainWebpack: config =&gt; &#123; config.resolve.alias .set(&apos;@&apos;, resolve(&apos;src&apos;)) .set(&apos;_lib&apos;, resolve(&apos;src/common&apos;)) .set(&apos;_com&apos;, resolve(&apos;src/components&apos;)) .set(&apos;_img&apos;, resolve(&apos;src/images&apos;)) .set(&apos;_ser&apos;, resolve(&apos;src/services&apos;)) &#125;, ...&#125; 需要注意的是对于在样式及html模版中引用路径的简写时，前面需要加上～，否则历经解析会失败123.img &#123; background: (~_img/home.png);&#125; 开启Gzip压缩 compression-webpack-plugin开启Gzip压缩 在vue.config.js中通过configureWebpack中返回一个对象来实现plugins的合并123456789101112131415161718192021222324252627282930/* vue.config.js */const isPro = process.env.NODE_ENV === &apos;production&apos;module.exports = &#123; ... configureWebpack: config =&gt; &#123; if (isPro) &#123; return &#123; plugins: [ new CompressionWebpackPlugin(&#123; // 目标文件名称。[path] 被替换为原始文件的路径和 [query] 查询 filename: &apos;[path].gz[query]&apos;, // 使用 gzip 压缩 algorithm: &apos;gzip&apos;, // 处理与此正则相匹配的所有文件 test: new RegExp( &apos;\\\\.(js|css)$&apos; ), // 只处理大于此大小的文件 threshold: 10240, // 最小压缩比达到 0.8 时才会被压缩 minRatio: 0.8， &#125;) ] &#125; &#125; &#125; ...&#125; 上方我们通过在生产环境中增加 Gzip 压缩配置实现了打包后输出增加对应的 .gz 为后缀的文件，而由于我们配置项中配置的是只压缩大小超过 10240B（10kB）的 JS 及 CSS，因此不满足条件的文件不会进行 Gzip 压缩。","categories":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/tags/vue/"},{"name":"优化","slug":"优化","permalink":"http://dongxin03.github.io/tags/%E4%BC%98%E5%8C%96/"}]},{"title":"vue 3、单页面|多页面","slug":"vue 3、单页面|多页面","date":"2019-11-25T08:05:33.000Z","updated":"2019-11-25T08:11:10.000Z","comments":true,"path":"2019/11/25/vue 3、单页面|多页面/","link":"","permalink":"http://dongxin03.github.io/2019/11/25/vue%203%E3%80%81%E5%8D%95%E9%A1%B5%E9%9D%A2|%E5%A4%9A%E9%A1%B5%E9%9D%A2/","excerpt":"","text":"单页面 – 多页面 单页面有一个html ，多页面有多个html 多页面应用拥有多个独立的入口文件、组件、路由、vuex等1234567891011121314151617181920212223242526├── node_modules # 项目依赖包目录├── build # 项目 webpack 功能目录├── config # 项目配置项文件夹├── src # 前端资源目录│ ├── images # 图片目录│ ├── components # 公共组件目录│ ├── pages # 页面目录│ │ ├── page1 # page1 目录│ │ │ ├── components # page1 组件目录│ │ │ ├── router # page1 路由目录│ │ │ ├── views # page1 页面目录│ │ │ ├── page1.html # page1 html 模板│ │ │ ├── page1.vue # page1 vue 配置文件│ │ │ └── page1.js # page1 入口文件│ │ ├── page2 # page2 目录│ │ └── index # index 目录│ ├── common # 公共方法目录│ └── store # 状态管理 store 目录├── .gitignore # git 忽略文件├── .env # 全局环境配置文件├── .env.dev # 开发环境配置文件├── .postcssrc.js # postcss 配置文件├── babel.config.js # babel 配置文件├── package.json # 包管理文件├── vue.config.js # CLI 配置文件└── yarn.lock # yarn 依赖信息文件 多个入口文件 需要配置webpack中的entry属性1234567891011module.exports = &#123; ... entry: &#123; page1: &apos;/xxx/pages/page1/page1.js&apos;, page2: &apos;/xxx/pages/page2/page2.js&apos;, index: &apos;/xxx/pages/index/index.js&apos;, &#125;, ...&#125; 如何读取这些路径，需要新建build文件夹存放utils.js这样公用的webpack功能性文件12345678910111213141516171819202122232425262728293031/* utils.js */const path = require(&apos;path&apos;);// glob 是 webpack 安装时依赖的一个第三方模块，该模块允许你使用 * 等符号,// 例如 lib/*.js 就是获取 lib 文件夹下的所有 js 后缀名的文件// yarn add glob --devconst glob = require(&apos;glob&apos;);// 取得相应的页面路径，因为之前的配置，所以是 src 文件夹下的 pages 文件夹const PAGE_PATH = path.resolve(__dirname, &apos;../src/pages&apos;);/* * 多入口配置* 通过 glob 模块读取 pages 文件夹下的所有对应文件夹下的 js * 后缀文件，如果该文件存在* 那么就作为入口处理*/exports.getEntries = () =&gt; &#123; let entryFiles = glob.sync(PAGE_PATH + &apos;/*/*.js&apos;) // 同步读取所有入口文件 let map = &#123;&#125; // 遍历所有入口文件 entryFiles.forEach(filePath =&gt; &#123; // 获取文件名 let filename = filePath.substring(filePath.lastIndexOf(&apos;\\/&apos;) + 1, filePath.lastIndexOf(&apos;.&apos;)) // 以键值对的形式存储 map[filename] = filePath &#125;) return map&#125; 读取并存储完毕后，我们得到了一个入口文件的对象集合，这个对象我们便可以将其设置到 webpack 的 entry 属性上，这里我们需要修改 vue.config.js 的配置来间接修改 webpack 的值：12345678910111213/* vue.config.js */const utils = require(&apos;./build/utils&apos;)module.exports = &#123; ... configureWebpack: config =&gt; &#123; config.entry = utils.getEntries() &#125;, ...&#125;","categories":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/tags/vue/"},{"name":"页面","slug":"页面","permalink":"http://dongxin03.github.io/tags/%E9%A1%B5%E9%9D%A2/"}]},{"title":"vue 2、router|vuex|api","slug":"vue 2、router|vuex|api","date":"2019-11-25T08:01:47.000Z","updated":"2019-11-25T08:01:34.000Z","comments":true,"path":"2019/11/25/vue 2、router|vuex|api/","link":"","permalink":"http://dongxin03.github.io/2019/11/25/vue%202%E3%80%81router|vuex|api/","excerpt":"","text":"vue-router1234567891011121314151617181920/* router.js */import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;import Home from &apos;./views/Home.vue&apos; // 引入 Home 组件import About from &apos;./views/About.vue&apos; // 引入 About 组件Vue.use(Router) // 注册路由export default new Router(&#123; routes: [&#123; path: &apos;/&apos;, name: &apos;home&apos;, component: Home &#125;, &#123; path: &apos;/about&apos;, name: &apos;about&apos;, component: About &#125;]&#125;) 如果路由存在二级目录，需要添加base属性，否则默认为”/“ 默认路由模式是hash模式，会携带#标记，与真是url不符合，可以还未history模式 页面组件没有进行按需加载，可以使用require.ensure()来进行优化123456789101112131415161718192021222324252627282930313233343536/* router.js */import Vue from &apos;vue&apos;import Router from &apos;vue-router&apos;// 引入 Home 组件const Home = resolve =&gt; &#123; require.ensure([&apos;./views/Home.vue&apos;], () =&gt; &#123; resolve(require(&apos;./views/Home.vue&apos;)) &#125;)&#125;// 引入 About 组件const About = resolve =&gt; &#123; require.ensure([&apos;./views/About.vue&apos;], () =&gt; &#123; resolve(require(&apos;./views/About.vue&apos;)) &#125;)&#125;Vue.use(Router)let base = `$&#123;process.env.BASE_URL&#125;` // 动态获取二级目录export default new Router(&#123; mode: &apos;history&apos;, base: base, routes: [&#123; path: &apos;/&apos;, name: &apos;home&apos;, component: Home &#125;, &#123; path: &apos;/about&apos;, name: &apos;about&apos;, component: About &#125;]&#125;) 当然，处理使用reauire.ensure来拆分代码，Vue Router官方文档还推荐使用动态import 愈发来进行代码分块12345// 引入 Home 组件const Home = () =&gt; import(&apos;./views/Home.vue&apos;);// 引入 About 组件const About = () =&gt; import(&apos;./views/About.vue&apos;); 如果你想给拆分出的文件命名，可以尝试一下webpack提供的Magic Comments（魔法注释）1const Home = () =&gt; import(/* webpackChunkName:&apos;home&apos;*/ &apos;./views/Home.vue&apos;); Vuex配置 vue-cli 生成的store12345678910111213141516import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; &#125;, mutations: &#123; &#125;, actions: &#123; &#125;&#125;) 主要是4个核心点 state 存放变量 this.$store.state 获取 getters 计算变量 计算state后返回 this.$store.getter || mapGetters 获取 mutations 修改state值唯一的办法是派发 mutaion this.$store.commit() actions 派发actions 可以异步派发mutaion this.$store.dispatch(actions) modules 划分模块引入123456789101112131415161718192021222324252627/* moduleA.js */const moduleA = &#123; state: &#123; text: &apos;hello&apos; &#125;, mutations: &#123; addText (state, txt) &#123; // 这里的 `state` 对象是模块的局部状态 state.text += txt &#125; &#125;, actions: &#123; setText (&#123; commit &#125;) &#123; commit(&apos;addText&apos;, &apos; world&apos;) &#125; &#125;, getters: &#123; getText (state) &#123; return state.text + &apos;!&apos; &#125; &#125;&#125;export default moduleA a模块引入1234567891011121314151617181920212223242526272829/* index.js */import Vue from &apos;vue&apos;import Vuex from &apos;vuex&apos;import moduleA from &apos;./modules/moduleA&apos;import moduleB from &apos;./modules/moduleB&apos;import &#123; mutations &#125; from &apos;./mutations&apos;import actions from &apos;./actions&apos;Vue.use(Vuex)export default new Vuex.Store(&#123; state: &#123; groups: [1] &#125;, modules: &#123; moduleA, // 引入 A 模块 moduleB, // 引入 B 模块 &#125;, actions, // 根级别的 action mutations, // 根级别的 mutations // 根级别的 getters getters: &#123; getGroups (state) &#123; return state.groups &#125; &#125; &#125;) 接口配置 简单封装ajax12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485/* http.js */import &apos;whatwg-fetch&apos;// HTTP 工具类export default class Http &#123; static async request(method, url, data) &#123; const param = &#123; method: method, headers: &#123; &apos;Content-Type&apos;: &apos;application/json&apos; &#125; &#125;; if (method === &apos;GET&apos;) &#123; url += this.formatQuery(data) &#125; else &#123; param[&apos;body&apos;] = JSON.stringify(data) &#125; // Tips.loading(); // 可调用 loading 组件 return fetch(url, param).then(response =&gt; this.isSuccess(response)) .then(response =&gt; &#123; return response.json() &#125;) &#125; // 判断请求是否成功 static isSuccess(res) &#123; if (res.status &gt;= 200 &amp;&amp; res.status &lt; 300) &#123; return res &#125; else &#123; this.requestException(res) &#125; &#125; // 处理异常 static requestException(res) &#123; const error = new Error(res.statusText) error.response = res throw error &#125; // url处理 static formatQuery(query) &#123; let params = []; if (query) &#123; for (let item in query) &#123; let vals = query[item]; if (vals !== undefined) &#123; params.push(item + &apos;=&apos; + query[item]) &#125; &#125; &#125; return params.length ? &apos;?&apos; + params.join(&apos;&amp;&apos;) : &apos;&apos;; &#125; // 处理 get 请求 static get(url, data) &#123; return this.request(&apos;GET&apos;, url, data) &#125; // 处理 put 请求 static put(url, data) &#123; return this.request(&apos;PUT&apos;, url, data) &#125; // 处理 post 请求 static post(url, data) &#123; return this.request(&apos;POST&apos;, url, data) &#125; // 处理 patch 请求 static patch(url, data) &#123; return this.request(&apos;PATCH&apos;, url, data) &#125; // 处理 delete 请求 static delete(url, data) &#123; return this.request(&apos;DELETE&apos;, url, data) &#125;&#125; 创建一个api集合文件1234567/* moduleA.js */import Http from &apos;./http&apos;// 获取测试数据export const getTestData = () =&gt; &#123; return Http.get(&apos;https://api.github.com/repos/octokit/octokit.rb&apos;)&#125; 可以省略 url部分1234567/* moduleA.js */import Http from &apos;./http&apos;// 获取测试数据export const getTestData = () =&gt; &#123; return Http.get(&apos;/repos/octokit/octokit.rb&apos;)&#125; 需要配置vue.config.js123456789101112131415161718192021/* vue.config.js */module.exports = &#123; ... devServer: &#123; // string | Object 代理设置 proxy: &#123; // 接口是 &apos;/repos&apos; 开头的才用代理 &apos;/repos&apos;: &#123; target: &apos;https://api.github.com&apos;, // 目标地址 changeOrigin: true, // 是否改变源地址 // pathRewrite: &#123;&apos;^/api&apos;: &apos;&apos;&#125; &#125; &#125;, &#125; ...&#125; 在 devServer 中 我们配置 proxy 进行接口的代理，将我们本地地址转换为真实的服务器地址，此时我们同样能顺利的获取到数据，不同点在于接口状态变成了 304（重定向)","categories":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/tags/vue/"},{"name":"router","slug":"router","permalink":"http://dongxin03.github.io/tags/router/"},{"name":"vuex","slug":"vuex","permalink":"http://dongxin03.github.io/tags/vuex/"},{"name":"api","slug":"api","permalink":"http://dongxin03.github.io/tags/api/"}]},{"title":"vue 1、构建基础","slug":"vue 1、构建基础","date":"2019-11-25T07:46:47.000Z","updated":"2019-11-25T07:57:51.000Z","comments":true,"path":"2019/11/25/vue 1、构建基础/","link":"","permalink":"http://dongxin03.github.io/2019/11/25/vue%201%E3%80%81%E6%9E%84%E5%BB%BA%E5%9F%BA%E7%A1%80/","excerpt":"","text":"npm与yarn webpack 环境配置 接口配置 单页应用 多页应用 开发技巧 实用工具依赖工具 node -v 查看node版本 npm -v 查看npm版本脚手架安装 npm i -g @vue/cli // i == install yarn global add @vue/cli创建一个新项目 vue creact my-page 构建一个基础项目一般需要（Babel\\Router\\Vuex\\CSS Pre-processors） npm install || yarn vue ui //可视化界面启动 cd my-page yarn serve || npm run serve // 看package.jsonnpm与package.json npm 是node 的包管理工具 npm-start 可以查看 一定时间范围内的包下载数据 dependencies 生产环境 devDependencies 开发环境npm常用命令 npm init //生成 package.json 文件（需要手动选择配置） npm init -y // 生成 package.json 文件（使用默认配置） npm i || npm install // 安装package.json 下的依赖包 npm i xxx 安装相应的包 (dependencies) npm i xxx –save (dependencies) npm i xxx –save-dev (devDependencies) npm i -g xxx 全局安装 npm run dev || npm run start npm home xxx //打开包的github 主页 npm repo xxx //打开包的github 仓库 yarn outdated xxx //查看包版本 yarn check //验证当前项目package.json 里的依赖版本和yarn的lock文件是否匹配 npm publich || yarn pubilsh 发布版本到npmjs.com第三方插件配置 package.json 文件中 browserslict 在不同的包之间共享目标浏览器和node版本 “&gt; 1%” // 表示包含所有使用率 &gt; 1% 浏览器 “last 2 versions” // 表示包含浏览器最新的两个版本 “not ie &lt;= 8” // 表示不包含 ie8 以及以下版本 也可以单独写在 .browserslistrc 文件中 官网可以搜索包含浏览器列表等待 npx browserslist 命令查看适配的浏览器vue add 命令 是能安装Vue集成的包 vue add router // vue-router vue add vuex //vuexwebpack 的使用 vue-cli 2.x 版本 会有相应的webpack配置文件 vue-cli 3.x 版本 提供了 vue.config.js vue.config.js 的配置 vue-cli 3.x =&gt; 如果你构建的项目中没有该文件，那么你需要在根目录手动创建。baseUrl 给项目地址增加二级目录 123456789// vue.config.js// localhost:8080/ =&gt; localhost:8080/vue/module.exports = &#123; ... baseUrl: &apos;vue&apos;, ...&#125; 对应webpack 文件中output的publicPathoutputDir 项目打包输出地址（默认是dist文件夹）123456789// vue.config.js// 打包输出到output文件夹module.exports = &#123; ... outputDir: &apos;output&apos;, ...&#125; 对应webpack 文件中output的pathproductionSourceMap 是否为生产环境构建生成 source map,用于快速定位错误信息 该配置会修改webpack中devtool项的值为source-mapchainWebpack 集成的是webpack-chain 1234567891011121314151617181920// 用于做相应的合并处理const merge = require(&apos;webpack-merge&apos;);module.exports = &#123; ... // config 参数为已经解析好的 webpack 配置 chainWebpack: config =&gt; &#123; config.module .rule(&apos;images&apos;) .use(&apos;url-loader&apos;) .tap(options =&gt; merge(options, &#123; limit: 5120, &#125;) ) &#125; ...&#125; 这里需要注意的是我们使用了 webpack-merge 这一插件，该插件用于做 webpack 配置的合并处理，这样 options 下面的其他值就不会被覆盖或改变。 以上操作我们可以成功修改webpack中module项里rules规则为图片下的url-loader值，将limit限制改为5M，修改狗的webpack配置如下：123456789101112131415161718192021222324&#123; ... module: &#123; rules: [ &#123; /* config.module.rule(&apos;images&apos;) */ test: /\\.(png|jpe?g|gif|webp)(\\?.*)?$/, use: [ /* config.module.rule(&apos;images&apos;).use(&apos;url-loader&apos;) */ &#123; loader: &apos;url-loader&apos;, options: &#123; limit: 5120, name: &apos;img/[name].[hash:8].[ext]&apos; &#125; &#125; ] &#125; ] &#125; ...&#125; configureWebpack 除了上述使用 chainWebpack 来改变 webpack 内部配置外，我们还可以使用 configureWebpack 来进行修改，两者的不同点在于 chainWebpack 是链式修改，而 configureWebpack 更倾向于整体替换和修改。示例代码如下： 12345678910111213141516// vue.config.jsmodule.exports = &#123; ... // config 参数为已经解析好的 webpack 配置 configureWebpack: config =&gt; &#123; // config.plugins = []; // 这样会直接将 plugins 置空 // 使用 return 一个对象会通过 webpack-merge 进行合并，plugins 不会置空 return &#123; plugins: [] &#125; &#125; ...&#125; configureWebpack 可以直接是一个对象，也可以是一个函数，如果是对象它会直接使用 webpack-merge 对其进行合并处理，如果是函数，你可以直接使用其 config 参数来修改 webpack 中的配置，或者返回一个对象来进行 merge 处理。 vue inspect 查看修改狗的webpack完整配置 vue inspect plugins 值查看plugins的内容 devServer vue.config.js提供了devServer项用于配置webpack-dev-server的行为 在运行yarn server 对应的 vue-cli-service serve 其实便是基于webpack-dev-server开启一个本地服务，其常用参数如下12345678910111213141516171819// vue.config.jsmodule.exports = &#123; ... devServer: &#123; open: true, // 是否自动打开浏览器页面 host: &apos;0.0.0.0&apos;, // 指定使用一个 host。默认是 localhost port: 8080, // 端口地址 https: false, // 使用https提供服务 proxy: null, // string | Object 代理设置 // 提供在服务器内部的其他中间件之前执行自定义中间件的能力 before: app =&gt; &#123; // `app` 是一个 express 实例 &#125; &#125; ...&#125; 当然除了以上参数，其支持所有的 webpack-dev-server 中的选项，比如 historyApiFallback 用于重写路由（会在后续的多页应用配置中讲解）、progress 将运行进度输出到控制台等 具体可参考devServer默认插件介绍123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263// vue-loader是 webpack 的加载器，允许你以单文件组件的格式编写 Vue 组件const VueLoaderPlugin = require(&apos;vue-loader/lib/plugin&apos;);// webpack 内置插件，用于创建在编译时可以配置的全局常量const &#123; DefinePlugin &#125; = require(&apos;webpack&apos;);// 用于强制所有模块的完整路径必需与磁盘上实际路径的确切大小写相匹配const CaseSensitivePathsPlugin = require(&apos;case-sensitive-paths-webpack-plugin&apos;);// 识别某些类型的 webpack 错误并整理，以提供开发人员更好的体验。const FriendlyErrorsPlugin = require(&apos;friendly-errors-webpack-plugin&apos;);// 将 CSS 提取到单独的文件中，为每个包含 CSS 的 JS 文件创建一个 CSS 文件const MiniCssExtractPlugin = require(&quot;mini-css-extract-plugin&quot;);// 用于在 webpack 构建期间优化、最小化 CSS文件const OptimizeCssnanoPlugin = require(&apos;optimize-css-assets-webpack-plugin&apos;);// webpack 内置插件，用于根据模块的相对路径生成 hash 作为模块 id, 一般用于生产环境const &#123; HashedModuleIdsPlugin &#125; = require(&apos;webpack&apos;);// 用于根据模板或使用加载器生成 HTML 文件const HtmlWebpackPlugin = require(&apos;html-webpack-plugin&apos;);// 用于在使用 html-webpack-plugin 生成的 html 中添加 &lt;link rel =&apos;preload&apos;&gt; 或 &lt;link rel =&apos;prefetch&apos;&gt;，有助于异步加载const PreloadPlugin = require(&apos;preload-webpack-plugin&apos;);// 用于将单个文件或整个目录复制到构建目录const CopyWebpackPlugin = require(&apos;copy-webpack-plugin&apos;);module.exports = &#123; plugins: [ /* config.plugin(&apos;vue-loader&apos;) */ new VueLoaderPlugin(), /* config.plugin(&apos;define&apos;) */ new DefinePlugin(), /* config.plugin(&apos;case-sensitive-paths&apos;) */ new CaseSensitivePathsPlugin(), /* config.plugin(&apos;friendly-errors&apos;) */ new FriendlyErrorsWebpackPlugin(), /* config.plugin(&apos;extract-css&apos;) */ new MiniCssExtractPlugin(), /* config.plugin(&apos;optimize-css&apos;) */ new OptimizeCssnanoPlugin(), /* config.plugin(&apos;hash-module-ids&apos;) */ new HashedModuleIdsPlugin(), /* config.plugin(&apos;html&apos;) */ new HtmlWebpackPlugin(), /* config.plugin(&apos;preload&apos;) */ new PreloadPlugin(), /* config.plugin(&apos;copy&apos;) */ new CopyWebpackPlugin() ]&#125; 需要注意的是要区分 webpack 内置插件和第三方插件的区别，如果是内置插件则无需安装下载，而外部插件大家可以直接访问：www.npmjs.com/ 搜索对应的插件","categories":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/categories/vue/"}],"tags":[{"name":"vue","slug":"vue","permalink":"http://dongxin03.github.io/tags/vue/"},{"name":"构建","slug":"构建","permalink":"http://dongxin03.github.io/tags/%E6%9E%84%E5%BB%BA/"}]},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2019-11-25T02:25:24.000Z","updated":"2019-11-25T08:02:42.000Z","comments":true,"path":"2019/11/25/Markdown基本语法/","link":"","permalink":"http://dongxin03.github.io/2019/11/25/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","excerpt":"","text":"1、标题123456# 这是一级标题## 这是二级标题### 这是三级标题#### 这是四级标题##### 这是五级标题###### 这是六级标题 这是一级标题这是二级标题这是三级标题这是四级标题这是五级标题这是六级标题 2、字体1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 这是加粗的文字这是倾斜的文字`这是斜体加粗的文字这是加删除线的文字 3、引用123&gt;这是引用的内容&gt;&gt;这是引用的内容&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;这是引用的内容 这是引用的内容 这是引用的内容 这是引用的内容 4、分割线1234-------******** 5、图片![图片alt](图片地址 ‘’图片title’’) 图片alt就是显示在图片下面的文字，相当于对图片内容的解释。图片title是图片的标题，当鼠标移到图片上时显示的内容。title可加可不加 1![Image text](https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/) 6、超链接12[超链接名](超链接地址 &quot;超链接title&quot;)title可加可不加 简书百度 7、列表无序列表无序列表用 - + * 任何一种都可以 123- 列表内容+ 列表内容* 列表内容 列表内容 列表内容 列表内容 有序列表1231.列表内容2.列表内容3.列表内容 列表内容 列表内容 列表内容 列表嵌套上一级和下一级之间敲三个空格即可 嵌套 嵌套一 嵌套二 嵌套三 8、表格1234567891011表头|表头|表头:---|:--:|---:内容|内容|内容内容|内容|内容第二行分割表头和内容。- 有一个就行，为了对齐，多加了几个文字默认居左-两边加：表示文字居中-右边加：表示文字居右注：原生的语法两边都要用 | 包起来。此处省略 表头 表头 表头 内容 内容 内容 内容 内容 内容 9、代码1`单行代码` 单行代码 123456(```) function fun()&#123; return &quot;为了防止转译，前后三个反引号处加了小括号，实际是没有的。这里只是用来演示，实际中去掉两边小括号即可&quot;; &#125; fun();(```) 1234function fun()&#123; return &quot;这是一句非常牛逼的代码&quot;;&#125;fun(); 参考 Markdown基本语法（高鸿祥）","categories":[{"name":"语法","slug":"语法","permalink":"http://dongxin03.github.io/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"Markdown","slug":"Markdown","permalink":"http://dongxin03.github.io/tags/Markdown/"},{"name":"语法","slug":"语法","permalink":"http://dongxin03.github.io/tags/%E8%AF%AD%E6%B3%95/"}]}]}